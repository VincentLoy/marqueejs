{"version":3,"file":"marqueejs.umd.min.js","sources":["../src/core/OptionsValidator.ts","../src/core/managers/AnimationManager.ts","../src/core/managers/EventManager.ts","../src/core/managers/CloneCalculator.ts","../src/core/managers/DOMManager.ts","../src/core/Marquee.ts","../src/index.ts"],"sourcesContent":["import type {\n  MarqueeOptions,\n  ContentValidationResult,\n  ContentValidationErrorType,\n  ContentValidationOptions,\n} from \"../types\";\n\nexport class OptionsValidator {\n  static readonly MAX_CLONES = 30;\n  static readonly MIN_CLONES = 0;\n  static readonly DEFAULT_MAX_LENGTH = 8500;\n\n  private static readonly FORBIDDEN_TAGS = [\n    \"script\",\n    \"style\",\n    \"iframe\",\n    \"object\",\n    \"embed\",\n    \"form\",\n    \"svg\",\n    \"input\",\n    \"button\",\n    \"meta\",\n    \"link\",\n    \"head\",\n    \"html\",\n    \"body\",\n  ];\n\n  private static readonly FORBIDDEN_ATTRIBUTES = [\n    \"onclick\",\n    \"onmouseover\",\n    \"onmouseout\",\n    \"onload\",\n    \"onerror\",\n    \"onsubmit\",\n    \"formaction\",\n    \"xlink:href\",\n    \"action\",\n    \"javascript\",\n  ];\n\n  private static readonly DEFAULT_VALIDATION_OPTIONS = {\n    maxLength: OptionsValidator.DEFAULT_MAX_LENGTH,\n    forbiddenTags: OptionsValidator.FORBIDDEN_TAGS,\n    forbiddenAttributes: OptionsValidator.FORBIDDEN_ATTRIBUTES,\n  } as const;\n\n  static validate(options: MarqueeOptions): MarqueeOptions {\n    this.validateSpeed(options.speed);\n    this.validateDirection(options.direction);\n    this.validateGap(options.gap);\n\n    // Initialize contentValidation with defaults if not provided\n    if (!options.contentValidation) {\n      options.contentValidation = this.DEFAULT_VALIDATION_OPTIONS;\n    } else {\n      options.contentValidation = {\n        maxLength: options.contentValidation.maxLength || this.DEFAULT_MAX_LENGTH,\n        forbiddenTags: [...this.FORBIDDEN_TAGS, ...(options.contentValidation.forbiddenTags || [])],\n        forbiddenAttributes: [\n          ...this.FORBIDDEN_ATTRIBUTES,\n          ...(options.contentValidation.forbiddenAttributes || []),\n        ],\n      };\n    }\n\n    // Add contentList validation\n    if (options.contentList) {\n      const validationResult = this.validateContentList(options.contentList, options);\n      if (!validationResult.isValid) {\n        console.warn(\n          \"MarqueeJS: Content list validation failed:\",\n          validationResult.errors.map((e) => e.message).join(\", \")\n        );\n        options.contentList = options.contentList.filter(\n          (_, index) => !validationResult.errors.some((e) => e.index === index)\n        );\n      }\n    }\n\n    // Handle clone count separately to return modified options\n    if (options.cloneCount !== undefined) {\n      if (options.cloneCount === \"auto\") {\n        // 'auto' est une valeur valide, ne rien faire\n      } else if (!Number.isInteger(options.cloneCount) || options.cloneCount < 0) {\n        console.warn(\n          `MarqueeJS: Requested ${options.cloneCount} clones, but minimum is ${this.MIN_CLONES}. Using ${this.MIN_CLONES} clones instead.`\n        );\n        options.cloneCount = this.MIN_CLONES;\n      } else if (typeof options.cloneCount === \"number\" && options.cloneCount > this.MAX_CLONES) {\n        console.warn(\n          `MarqueeJS: Requested ${options.cloneCount} clones, but maximum is ${this.MAX_CLONES}. Using ${this.MAX_CLONES} clones instead.`\n        );\n        options.cloneCount = this.MAX_CLONES;\n      }\n    }\n\n    // Remove separator for vertical directions\n    if ([\"up\", \"down\"].includes(options.direction || \"\") && options.separator) {\n      console.warn(\n        \"MarqueeJS: Separator is not supported for vertical directions. Separator will be ignored.\"\n      );\n      options.separator = \"\";\n    }\n\n    this.validateContainerHeight(options.containerHeight, options.direction);\n    this.validateKeepOriginalContent(options.keepOriginalContent);\n    this.validateContentValidationOptions(options.contentValidation);\n\n    return options;\n  }\n\n  public static validateContentList(\n    contentList: string[],\n    options: MarqueeOptions\n  ): ContentValidationResult {\n    const errors: {\n      type: ContentValidationErrorType;\n      message: string;\n      content?: string;\n      index?: number;\n    }[] = [];\n\n    if (!Array.isArray(contentList)) {\n      return {\n        isValid: false,\n        errors: [\n          {\n            type: \"INVALID_HTML\" as ContentValidationErrorType,\n            message: \"Content list must be an array of strings\",\n          },\n        ],\n      };\n    }\n\n    // Create a complete validation options object with all required properties\n    const validationOptions = {\n      ...this.DEFAULT_VALIDATION_OPTIONS,\n      ...options.contentValidation,\n      forbiddenTags: [...this.FORBIDDEN_TAGS, ...(options.contentValidation?.forbiddenTags || [])],\n      forbiddenAttributes: [\n        ...this.FORBIDDEN_ATTRIBUTES,\n        ...(options.contentValidation?.forbiddenAttributes || []),\n      ],\n      maxLength: options.contentValidation?.maxLength || this.DEFAULT_MAX_LENGTH,\n    };\n\n    const forbiddenTagsPattern = new RegExp(\n      `</?(?:${validationOptions.forbiddenTags.join(\"|\")})\\\\b[^>]*>`,\n      \"i\"\n    );\n    const forbiddenAttrsPattern = new RegExp(\n      validationOptions.forbiddenAttributes\n        .map((attr) => `${attr}\\\\s*=\\\\s*[\"']?[^\"']*[\"']?`)\n        .join(\"|\"),\n      \"i\"\n    );\n\n    for (let i = 0; i < contentList.length; i++) {\n      const content = contentList[i];\n\n      // Check for empty or non-string content\n      if (!content || typeof content !== \"string\") {\n        errors.push({\n          type: \"EMPTY_CONTENT\" as ContentValidationErrorType,\n          message: \"Content item must be a non-empty string\",\n          index: i,\n          content,\n        });\n        continue;\n      }\n\n      // Check for forbidden tags\n      if (forbiddenTagsPattern.test(content)) {\n        errors.push({\n          type: \"UNSAFE_TAG_DETECTED\" as ContentValidationErrorType,\n          message: \"Content contains forbidden HTML tags\",\n          index: i,\n          content: content.substring(0, 50) + \"...\",\n        });\n        continue;\n      }\n\n      // Check for forbidden attributes\n      if (forbiddenAttrsPattern.test(content)) {\n        errors.push({\n          type: \"UNSAFE_ATTRIBUTES\" as ContentValidationErrorType,\n          message: \"Content contains forbidden HTML attributes\",\n          index: i,\n          content: content.substring(0, 50) + \"...\",\n        });\n        continue;\n      }\n\n      // Check for user-defined or default length\n      if (content.length > validationOptions.maxLength) {\n        errors.push({\n          type: \"MAX_LENGTH_EXCEEDED\" as ContentValidationErrorType,\n          message: `Content item exceeds maximum length of ${validationOptions.maxLength} characters`,\n          index: i,\n          content: content.substring(0, 50) + \"...\",\n        });\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n\n  public static validateContentValidationOptions(\n    validationOptions: ContentValidationOptions\n  ): void {\n    if (\n      validationOptions.maxLength !== undefined &&\n      (typeof validationOptions.maxLength !== \"number\" || validationOptions.maxLength <= 0)\n    ) {\n      throw new Error(\"MarqueeJS: maxLength must be a positive number\");\n    }\n\n    if (\n      validationOptions.forbiddenTags !== undefined &&\n      (!Array.isArray(validationOptions.forbiddenTags) ||\n        validationOptions.forbiddenTags.some((tag) => typeof tag !== \"string\"))\n    ) {\n      throw new Error(\"MarqueeJS: forbiddenTags must be an array of strings\");\n    }\n\n    if (\n      validationOptions.forbiddenAttributes !== undefined &&\n      (!Array.isArray(validationOptions.forbiddenAttributes) ||\n        validationOptions.forbiddenAttributes.some((attr) => typeof attr !== \"string\"))\n    ) {\n      throw new Error(\"MarqueeJS: forbiddenAttributes must be an array of strings\");\n    }\n  }\n  public static validateSpeed(speed: number | undefined): void {\n    if (speed !== undefined && (typeof speed !== \"number\" || speed <= 0)) {\n      throw new Error(\"MarqueeJS: Speed must be a positive number\");\n    }\n  }\n\n  public static validateDirection(direction: string | undefined): void {\n    const validDirections = [\"left\", \"right\", \"up\", \"down\"];\n    if (direction && !validDirections.includes(direction)) {\n      throw new Error(`MarqueeJS: Direction must be one of: ${validDirections.join(\", \")}`);\n    }\n  }\n\n  public static validateGap(gap: number | undefined): void {\n    if (gap !== undefined && (typeof gap !== \"number\" || gap < 0)) {\n      throw new Error(\"MarqueeJS: Gap must be a non-negative number\");\n    }\n  }\n\n  public static validateContainerHeight(\n    containerHeight: number | undefined,\n    direction: string | undefined\n  ): void {\n    if (containerHeight !== undefined) {\n      if (typeof containerHeight !== \"number\" || containerHeight <= 0) {\n        throw new Error(\"MarqueeJS: Container height must be a positive number\");\n      }\n      if (![\"up\", \"down\"].includes(direction || \"\")) {\n        console.warn(\n          'MarqueeJS: Container height is only applicable for \"up\" and \"down\" directions. Ignoring containerHeight.'\n        );\n      }\n    }\n  }\n\n  public static validateKeepOriginalContent(keepOriginalContent: boolean | undefined): void {\n    if (keepOriginalContent !== undefined && typeof keepOriginalContent !== \"boolean\") {\n      throw new Error(\"MarqueeJS: keepOriginalContent must be a boolean\");\n    }\n  }\n\n  public static validateCloneCount(cloneCount: number | \"auto\"): void {\n    if (\n      cloneCount !== \"auto\" &&\n      (!Number.isInteger(cloneCount) || cloneCount < 0 || cloneCount > this.MAX_CLONES)\n    ) {\n      throw new Error(\n        `MarqueeJS: cloneCount must be 'auto' or an integer between ${this.MIN_CLONES} and ${this.MAX_CLONES}`\n      );\n    }\n  }\n}\n","import type { MarqueeOptions } from \"../../types\";\n\nexport class AnimationManager {\n  private wrapper: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private animationFrame: number | null = null;\n  private lastTime: number = 0;\n  private elements: Array<{ el: HTMLElement; position: number }> = [];\n\n  constructor(wrapper: HTMLElement, options: Partial<MarqueeOptions>) {\n    this.wrapper = wrapper;\n    this.options = options;\n    this.setupElements();\n  }\n\n  private setupElements(): void {\n    const groups = Array.from(this.wrapper.children) as HTMLElement[];\n    const isHorizontal = [\"left\", \"right\"].includes(this.options.direction!);\n    let currentPosition = 0;\n\n    this.elements = groups.map((group) => {\n      // Calculate size including gap\n      const size = isHorizontal\n        ? group.offsetWidth + this.options.gap!\n        : group.offsetHeight + this.options.gap!;\n\n      // Store current position for this element\n      const position = currentPosition;\n\n      // Position element\n      group.style.position = \"absolute\";\n      group.style.top = \"0\";\n      group.style.left = \"0\";\n      group.style.transform = isHorizontal\n        ? `translate3d(${position}px, 0, 0)`\n        : `translate3d(0, ${position}px, 0)`;\n\n      // Update position for next element\n      currentPosition += size;\n\n      return {\n        el: group,\n        position,\n      };\n    });\n  }\n\n  public startAnimation(): void {\n    this.lastTime = performance.now();\n\n    const animate = (currentTime: number) => {\n      const deltaTime = currentTime - this.lastTime;\n      this.lastTime = currentTime;\n      const movement = (this.options.speed! * deltaTime) / 1000;\n\n      // Update each element's position independently\n      this.elements.forEach((item) => {\n        if ([\"left\", \"right\"].includes(this.options.direction!)) {\n          this.updateHorizontalPosition(item, movement);\n        } else {\n          this.updateVerticalPosition(item, movement);\n        }\n      });\n\n      this.animationFrame = requestAnimationFrame(animate);\n    };\n\n    this.animationFrame = requestAnimationFrame(animate);\n  }\n\n  private isPositionAvailable(newPosition: number, currentElement: HTMLElement): boolean {\n    const threshold = this.options.gap!;\n    const isHorizontal = [\"left\", \"right\"].includes(this.options.direction!);\n\n    return !this.elements.some(({ el, position }) => {\n      if (el === currentElement) return false;\n\n      if (isHorizontal) {\n        const elementWidth = el.offsetWidth;\n        return Math.abs(position - newPosition) < elementWidth + threshold;\n      } else {\n        const elementHeight = el.offsetHeight;\n        return Math.abs(position - newPosition) < elementHeight + threshold;\n      }\n    });\n  }\n\n  private updateHorizontalPosition(\n    item: { el: HTMLElement; position: number },\n    movement: number\n  ): void {\n    const containerWidth = this.wrapper.parentElement?.offsetWidth || 0;\n    const elementWidth = item.el.offsetWidth;\n\n    if (this.options.direction === \"left\") {\n      item.position -= movement;\n\n      if (item.position + elementWidth < 0) {\n        const newPosition = containerWidth;\n        // Only reset if there's space available\n        if (this.isPositionAvailable(newPosition, item.el)) {\n          item.position = newPosition;\n        }\n      }\n    } else {\n      item.position += movement;\n\n      if (item.position > containerWidth) {\n        const newPosition = -elementWidth;\n        if (this.isPositionAvailable(newPosition, item.el)) {\n          item.position = newPosition;\n        }\n      }\n    }\n\n    item.el.style.transform = `translate3d(${item.position}px, 0, 0)`;\n  }\n\n  private updateVerticalPosition(\n    item: { el: HTMLElement; position: number },\n    movement: number\n  ): void {\n    const containerHeight = this.wrapper.parentElement?.offsetHeight || 0;\n    const elementHeight = item.el.offsetHeight;\n\n    if (this.options.direction === \"up\") {\n      item.position -= movement;\n      if (item.position + elementHeight < 0) {\n        const newPosition = containerHeight;\n        if (this.isPositionAvailable(newPosition, item.el)) {\n          item.position = newPosition;\n        }\n      }\n    } else {\n      item.position += movement;\n      if (item.position > containerHeight) {\n        const newPosition = -elementHeight;\n        if (this.isPositionAvailable(newPosition, item.el)) {\n          item.position = newPosition;\n        }\n      }\n    }\n\n    item.el.style.transform = `translate3d(0, ${item.position}px, 0)`;\n  }\n\n  public stopAnimation(): void {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n    this.lastTime = 0;\n  }\n\n  public recalculatePositions(): void {\n    // Stop current animation\n    this.stopAnimation();\n\n    // Reset and reinitialize positions\n    this.setupElements();\n\n    // Restart animation if it was running\n    this.startAnimation();\n  }\n}\n","import type { MarqueeOptions } from \"../../types\";\n\nexport class EventManager {\n  private wrapper: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private handlers: {\n    pause: () => void;\n    resume: () => void;\n  };\n\n  constructor(\n    _element: HTMLElement,\n    wrapper: HTMLElement,\n    options: Partial<MarqueeOptions>,\n    handlers: { pause: () => void; resume: () => void }\n  ) {\n    this.wrapper = wrapper;\n    this.options = options;\n    this.handlers = handlers;\n    this.init();\n  }\n\n  private init(): void {\n    this.setupHoverEvents();\n    this.setupTouchEvents();\n    this.setupVisibilityEvents();\n  }\n\n  private setupHoverEvents(): void {\n    if (this.options.pauseOnHover) {\n      this.wrapper.addEventListener(\"mouseenter\", this.handlers.pause);\n      this.wrapper.addEventListener(\"mouseleave\", this.handlers.resume);\n    }\n  }\n\n  private setupTouchEvents(): void {\n    let touchStartX: number;\n    let touchStartY: number;\n\n    // Add passive touch start listener\n    this.wrapper.addEventListener(\n      \"touchstart\",\n      (e: TouchEvent) => {\n        touchStartX = e.touches[0].clientX;\n        touchStartY = e.touches[0].clientY;\n        this.handlers.pause();\n      },\n      { passive: true }\n    );\n\n    // Add passive touch end listener\n    this.wrapper.addEventListener(\n      \"touchend\",\n      () => {\n        this.handlers.resume();\n      },\n      { passive: true }\n    );\n\n    // Separate touch move handler that can prevent default\n    const handleTouchMove = (e: TouchEvent) => {\n      const deltaX = e.touches[0].clientX - touchStartX;\n      const deltaY = e.touches[0].clientY - touchStartY;\n\n      if (\n        Math.abs(deltaX) > Math.abs(deltaY) &&\n        [\"left\", \"right\"].includes(this.options.direction!)\n      ) {\n        e.preventDefault();\n      } else if (\n        Math.abs(deltaY) > Math.abs(deltaX) &&\n        [\"up\", \"down\"].includes(this.options.direction!)\n      ) {\n        e.preventDefault();\n      }\n    };\n\n    // Add non-passive touch move listener only when needed\n    if ([\"left\", \"right\", \"up\", \"down\"].includes(this.options.direction!)) {\n      this.wrapper.addEventListener(\"touchmove\", handleTouchMove, {\n        passive: false,\n      });\n    } else {\n      this.wrapper.addEventListener(\"touchmove\", handleTouchMove, {\n        passive: true,\n      });\n    }\n  }\n\n  private setupVisibilityEvents(): void {\n    document.addEventListener(\"visibilitychange\", () => {\n      if (document.hidden) {\n        this.handlers.pause();\n      } else {\n        this.handlers.resume();\n      }\n    });\n  }\n\n  public destroy(): void {\n    if (this.options.pauseOnHover) {\n      this.wrapper.removeEventListener(\"mouseenter\", this.handlers.pause);\n      this.wrapper.removeEventListener(\"mouseleave\", this.handlers.resume);\n    }\n\n    this.wrapper.removeEventListener(\"touchstart\", this.handlers.pause);\n    this.wrapper.removeEventListener(\"touchend\", this.handlers.resume);\n    document.removeEventListener(\"visibilitychange\", this.handlers.pause);\n  }\n}\n","import type { CloneMetrics } from \"../../types\";\n\nexport class CloneCalculator {\n  private cachedMetrics: CloneMetrics | null = null;\n\n  constructor(private direction: \"left\" | \"right\" | \"up\" | \"down\") {}\n\n  public calculateOptimalCloneCount(\n    containerElement: HTMLElement,\n    contentElements: HTMLElement[],\n    gap: number\n  ): number {\n    const isHorizontal = [\"left\", \"right\"].includes(this.direction);\n\n    const metrics = this.calculateMetrics(containerElement, contentElements, gap, isHorizontal);\n\n    // If metrics are identical, return from cache\n    if (\n      this.cachedMetrics &&\n      this.cachedMetrics.containerSize === metrics.containerSize &&\n      this.cachedMetrics.contentSize === metrics.contentSize\n    ) {\n      return this.cachedMetrics.calculatedCount;\n    }\n\n    // Calculate minimum number of clones needed\n    // +1 to ensure continuous scrolling\n    const minClones = Math.ceil(metrics.containerSize / metrics.contentSize) + 1;\n\n    // Cache the new metrics\n    this.cachedMetrics = {\n      ...metrics,\n      calculatedCount: minClones,\n    };\n\n    return minClones;\n  }\n\n  private calculateMetrics(\n    container: HTMLElement,\n    elements: HTMLElement[],\n    gap: number,\n    isHorizontal: boolean\n  ): Omit<CloneMetrics, \"calculatedCount\"> {\n    const containerSize = isHorizontal ? container.offsetWidth : container.offsetHeight;\n\n    const contentSize = elements.reduce((total, el) => {\n      const size = isHorizontal ? el.offsetWidth : el.offsetHeight;\n      return total + size + gap;\n    }, 0);\n\n    return {\n      containerSize,\n      contentSize,\n    };\n  }\n\n  public invalidateCache(): void {\n    this.cachedMetrics = null;\n  }\n}\n","import type { MarqueeOptions, ElementMetrics } from \"../../types\";\nimport { CloneCalculator } from \"./CloneCalculator\";\n\nexport class DOMManager {\n  private container: HTMLElement;\n  private wrapper: HTMLElement;\n  private element: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private contentElements: HTMLElement[] = [];\n  private clones: HTMLElement[] = [];\n  private instanceId: string;\n  private separatorStyleElement: HTMLStyleElement | null = null;\n  private cloneCalculator: CloneCalculator;\n\n  constructor(element: HTMLElement, options: Partial<MarqueeOptions>) {\n    this.instanceId = `marquee-${Math.random().toString(36).substring(2, 9)}`;\n    this.element = element;\n    this.options = options;\n    this.container = this.createContainer();\n    this.wrapper = this.createWrapper();\n    this.cloneCalculator = new CloneCalculator(options.direction!);\n\n    // Clear original element since everything goes through contentList\n    this.element.innerHTML = \"\";\n\n    this.setupDOM();\n  }\n\n  private createContainer(): HTMLElement {\n    const container = document.createElement(\"div\");\n    container.classList.add(this.instanceId, \"marquee-container\");\n    const elementClasses = Array.from(this.element.classList);\n    const elementId = this.element.id;\n    container.classList.add(...elementClasses);\n    if (elementId) container.id = elementId;\n    container.style.width = \"100%\";\n    container.style.overflow = \"hidden\";\n    container.style.position = \"relative\";\n    return container;\n  }\n\n  private createWrapper(): HTMLElement {\n    const wrapper = document.createElement(\"div\");\n    wrapper.style.position = \"relative\";\n    wrapper.style.width = \"100%\";\n    wrapper.style.height = \"100%\";\n    wrapper.style.overflow = \"visible\";\n    wrapper.classList.add(\"marquee-wrapper\");\n    return wrapper;\n  }\n\n  public setupDOM(): void {\n    const originalHeight = this.getMaxContentHeight();\n\n    // Configure container height\n    if ([\"up\", \"down\"].includes(this.options.direction!) && this.options.containerHeight) {\n      this.container.style.height = `${this.options.containerHeight}px`;\n    } else {\n      this.container.style.height = `${originalHeight}px`;\n    }\n\n    // Insert into DOM\n    this.element.parentNode?.insertBefore(this.container, this.element);\n    this.container.appendChild(this.wrapper);\n\n    // Create content elements from contentList\n    this.createContentElements();\n  }\n\n  public createContentElements(): void {\n    // Clear existing elements\n    this.clearElements();\n\n    const fragment = document.createDocumentFragment();\n    this.options.contentList!.forEach((content) => {\n      const element = this.createContentElement(content);\n      this.contentElements.push(element);\n      fragment.appendChild(element);\n    });\n\n    this.wrapper.appendChild(fragment);\n    this.positionElements();\n    this.createClones();\n\n    // Add separator styles after creating elements\n    this.updateSeparatorStyles();\n  }\n\n  private clearElements(): void {\n    this.contentElements.forEach((el) => el.remove());\n    this.clones.forEach((el) => el.remove());\n    this.contentElements = [];\n    this.clones = [];\n  }\n\n  private getMaxContentHeight(): number {\n    const temp = document.createElement(\"div\");\n    temp.style.position = \"absolute\";\n    temp.style.visibility = \"hidden\";\n    temp.style.left = \"-9999px\";\n    document.body.appendChild(temp);\n\n    const heights = this.options.contentList!.map((content) => {\n      temp.innerHTML = content;\n      return temp.offsetHeight;\n    });\n\n    document.body.removeChild(temp);\n    return Math.max(...heights, 0);\n  }\n\n  private calculateMetrics(): ElementMetrics[] {\n    const isHorizontal = [\"left\", \"right\"].includes(this.options.direction!);\n    const metrics: ElementMetrics[] = [];\n    let currentPosition = 0;\n\n    this.contentElements.forEach((el, index) => {\n      const rect = el.getBoundingClientRect();\n      const size = isHorizontal ? rect.width : rect.height;\n      const separatorOffset =\n        this.options.separator && index < this.contentElements.length - 1\n          ? this.options.gap! / 2\n          : 0;\n\n      metrics.push({\n        size,\n        spacing: this.options.gap!,\n        position: currentPosition,\n        separatorOffset,\n      });\n\n      currentPosition += size + this.options.gap!;\n    });\n\n    return metrics;\n  }\n\n  private createContentElement(content: string): HTMLElement {\n    const element = document.createElement(\"div\");\n    element.className = \"marquee-content-item\";\n    element.style.position = \"absolute\";\n    element.style.whiteSpace = [\"up\", \"down\"].includes(this.options.direction!)\n      ? \"normal\"\n      : \"nowrap\";\n    element.style.width = [\"up\", \"down\"].includes(this.options.direction!) ? \"100%\" : \"auto\";\n    element.innerHTML = content;\n    return element;\n  }\n\n  private positionElements(): void {\n    const metrics = this.calculateMetrics();\n    this.contentElements.forEach((el, i) => {\n      const { position } = metrics[i];\n      el.style.transform = [\"left\", \"right\"].includes(this.options.direction!)\n        ? `translate3d(${position}px, 0, 0)`\n        : `translate3d(0, ${position}px, 0)`;\n    });\n  }\n\n  private createClones(): void {\n    // If cloneCount is 'auto', use CloneCalculator\n    const cloneCount =\n      this.options.cloneCount === \"auto\"\n        ? this.cloneCalculator.calculateOptimalCloneCount(\n            this.container,\n            this.contentElements,\n            this.options.gap!\n          )\n        : this.options.cloneCount!;\n\n    if (cloneCount! <= 0) return;\n\n    const metrics = this.calculateMetrics();\n    const totalSize = metrics.reduce((sum, m) => sum + m.size + m.spacing, 0);\n    const fragment = document.createDocumentFragment();\n\n    for (let i = 0; i < cloneCount; i++) {\n      const offset = totalSize * (i + 1);\n      this.contentElements.forEach((original, index) => {\n        const clone = original.cloneNode(true) as HTMLElement;\n        clone.setAttribute(\"aria-hidden\", \"true\");\n        clone.classList.add(\"marquee-cloned-item\");\n        clone.style.transform = [\"left\", \"right\"].includes(this.options.direction!)\n          ? `translate3d(${metrics[index].position + offset}px, 0, 0)`\n          : `translate3d(0, ${metrics[index].position + offset}px, 0)`;\n\n        this.clones.push(clone);\n        fragment.appendChild(clone);\n      });\n    }\n\n    this.wrapper.appendChild(fragment);\n  }\n\n  private updateSeparatorStyles(): void {\n    this.separatorStyleElement?.remove();\n\n    if (!this.options.separator || [\"up\", \"down\"].includes(this.options.direction!)) {\n      return;\n    }\n\n    const style = document.createElement(\"style\");\n    style.textContent = `\n      .${this.instanceId} .marquee-content-item::before {\n      content: '${this.options.separator}';\n      position: absolute;\n      left: -${this.options.gap! / 2}px;\n      transform: translate3d(-50%, 0, 0);\n      white-space: pre;\n      }\n    `;\n\n    document.head.appendChild(style);\n    this.separatorStyleElement = style;\n  }\n\n  private cleanupSeparatorStyles(): void {\n    this.separatorStyleElement?.remove();\n    this.separatorStyleElement = null;\n  }\n\n  // Utility method to force recalculation of clones\n  public recalculateClones(): void {\n    this.cloneCalculator.invalidateCache();\n    this.createContentElements();\n  }\n\n  public updateContainerHeight(height: number): void {\n    if (this.container) {\n      this.container.style.height = `${height}px`;\n    }\n  }\n\n  public updateSeparators(): void {\n    this.updateSeparatorStyles();\n  }\n\n  public getWrapper(): HTMLElement {\n    return this.wrapper;\n  }\n\n  public getContainer(): HTMLElement {\n    return this.container;\n  }\n\n  public getContentElements(): HTMLElement[] {\n    return this.contentElements;\n  }\n\n  public destroy(): void {\n    this.clearElements();\n    if (this.wrapper.parentNode) {\n      this.wrapper.parentNode.insertBefore(this.element, this.wrapper);\n      this.container.remove();\n    }\n    this.cleanupSeparatorStyles();\n    document.querySelector(`.${this.instanceId}`)?.remove();\n  }\n}\n","import type { MarqueeOptions } from \"../types\";\nimport { OptionsValidator } from \"./OptionsValidator\";\nimport { AnimationManager } from \"./managers/AnimationManager\";\nimport { EventManager } from \"./managers/EventManager\";\nimport { DOMManager } from \"./managers/DOMManager\";\n\nexport class Marquee {\n  private element!: HTMLElement;\n  private originalElement: HTMLElement;\n  private options!: Partial<MarqueeOptions>;\n  private isPlaying: boolean = false;\n  private animationManager: AnimationManager | null = null;\n  private eventManager: EventManager | null = null;\n  private domManager: DOMManager | null = null;\n  private htmlContentList: string[] = [];\n\n  private defaultOptions: Partial<MarqueeOptions> = {\n    speed: 100,\n    direction: \"left\",\n    pauseOnHover: false,\n    gap: 20,\n    cloneCount: \"auto\",\n    separator: \"\",\n    randomize: false,\n    contentList: [],\n  };\n\n  constructor(selector: string | HTMLElement, options: MarqueeOptions = {}) {\n    const element = typeof selector === \"string\" ? document.querySelector(selector) : selector;\n\n    if (!element) {\n      throw new Error(\"Invalid element selector\");\n    }\n\n    // Store a deep copy of the original element\n    this.originalElement = element.cloneNode(true) as HTMLElement;\n    this.setupInstance(element as HTMLElement, options);\n    this.init();\n  }\n\n  private setupInstance(element: HTMLElement, options: MarqueeOptions): void {\n    const validatedOptions = OptionsValidator.validate(options);\n    this.element = element;\n    this.options = { ...this.defaultOptions, ...validatedOptions };\n    this.htmlContentList = Array.from(this.element.children).map((child) => child.outerHTML);\n\n    // If contentList is empty, populate it with the direct children of the marquee element\n    if (!this.options.contentList?.length) {\n      this.options.contentList = this.htmlContentList;\n    } else if (this.htmlContentList.length && this.options.keepOriginalContent) {\n      // If contentList is not empty, but the original content should be kept, append it to the contentList\n      this.options.contentList = [...this.htmlContentList, ...this.options.contentList];\n    }\n\n    // Randomize contentList if required\n    if (this.options.randomize) {\n      this.options.contentList = this.randomizeContent();\n    }\n  }\n\n  private async init(): Promise<void> {\n    // Cleanup existing managers if they exist\n    this.destroy();\n\n    this.domManager = new DOMManager(this.element, this.options);\n    await this.domManager.createContentElements();\n\n    const wrapper = this.domManager.getWrapper();\n    const contentElements = this.domManager.getContentElements();\n\n    if (wrapper && contentElements.length > 0) {\n      this.animationManager = new AnimationManager(wrapper, this.options);\n      this.eventManager = new EventManager(this.element, wrapper, this.options, {\n        pause: () => this.pause(),\n        resume: () => this.play(),\n      });\n      this.play();\n    }\n  }\n\n  private randomizeContent(): string[] {\n    const shuffledContent = [...this.options.contentList!];\n    for (let i = shuffledContent.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffledContent[i], shuffledContent[j]] = [shuffledContent[j], shuffledContent[i]];\n    }\n    return shuffledContent;\n  }\n\n  public async reset(): Promise<void> {\n    return new Promise<void>(async (resolve) => {\n      // Stop current animation\n      this.pause();\n\n      // Recreate element from original\n      const newElement = this.originalElement.cloneNode(true) as HTMLElement;\n\n      // Replace old element with new one\n      if (this.element.parentElement) {\n        this.element.parentElement.replaceChild(newElement, this.element);\n      }\n\n      // Wait for cleanup to complete\n      await Promise.resolve(this.destroy());\n\n      // Completely reset the instance\n      this.setupInstance(newElement, this.options);\n\n      // Wait for initialization to complete\n      await this.init();\n\n      resolve();\n    });\n  }\n\n  public destroy(): Promise<void> {\n    return new Promise<void>((resolve) => {\n      this.pause();\n      this.animationManager?.stopAnimation();\n      this.eventManager?.destroy();\n      this.domManager?.destroy();\n\n      // S'assurer que le DOM a eu le temps de se mettre à jour\n      requestAnimationFrame(() => {\n        resolve();\n      });\n    });\n  }\n\n  public play(): void {\n    if (this.isPlaying) return;\n    this.isPlaying = true;\n    this.startAnimation();\n  }\n\n  public pause(): void {\n    if (!this.isPlaying) return;\n    this.isPlaying = false;\n    this.stopAnimation();\n  }\n\n  private startAnimation(): void {\n    this.animationManager?.startAnimation();\n  }\n\n  private stopAnimation(): void {\n    this.animationManager?.stopAnimation();\n  }\n\n  public async addContent(\n    content: string | string[],\n    addToStart: boolean = false,\n    reset: boolean = false,\n    callback?: () => void\n  ): Promise<void> {\n    if (!content) return;\n\n    if (reset) {\n      this.pause();\n    }\n\n    // Convert content to array if it's a string\n    const newContent = Array.isArray(content) ? content : [content];\n\n    // Validate new content\n    const validationResult = OptionsValidator.validateContentList(newContent, this.options);\n    if (!validationResult.isValid) {\n      console.warn(\n        \"MarqueeJS: Content validation failed:\",\n        validationResult.errors.map((e) => e.message).join(\", \")\n      );\n      return;\n    }\n\n    // Add new content to the contentList\n    if (addToStart) {\n      this.options.contentList = [...newContent, ...this.options.contentList!];\n    } else {\n      this.options.contentList = [...this.options.contentList!, ...newContent];\n    }\n\n    if (reset) {\n      // Wait for reset to complete\n      await this.reset();\n    } else {\n      // Recreate content elements\n      this.domManager?.createContentElements();\n\n      // Recalculate positions and restart animation\n      this.animationManager?.recalculatePositions();\n    }\n\n    if (callback) {\n      requestAnimationFrame(() => {\n        callback();\n      });\n    }\n  }\n\n  public replaceContent(newContentList: string[], callback?: () => void): void {\n    if (!Array.isArray(newContentList)) return;\n\n    // Validate new content list\n    const validationResult = OptionsValidator.validateContentList(newContentList, this.options);\n    if (!validationResult.isValid) {\n      console.warn(\n        \"MarqueeJS: Content validation failed:\",\n        validationResult.errors.map((e) => e.message).join(\", \")\n      );\n      return;\n    }\n\n    // Replace the contentList with the new one\n    this.options.contentList = newContentList;\n\n    // Recreate content elements\n    this.domManager?.createContentElements();\n\n    // Recalculate positions and restart animation\n    this.animationManager?.recalculatePositions();\n\n    if (callback) {\n      requestAnimationFrame(() => {\n        callback();\n      });\n    }\n  }\n\n  public getContentList(): string[] {\n    return this.options.contentList!;\n  }\n\n  public updateSpeed(speed: number): void {\n    OptionsValidator.validateSpeed(speed);\n    this.options.speed = speed;\n  }\n\n  public updateGap(gap: number): void {\n    OptionsValidator.validateGap(gap);\n    this.options.gap = gap;\n    this.domManager?.createContentElements();\n    this.animationManager?.recalculatePositions();\n  }\n\n  public updateSeparator(separator: string): void {\n    this.options.separator = separator;\n    this.domManager?.createContentElements();\n    this.animationManager?.recalculatePositions();\n  }\n\n  public updateCloneCount(cloneCount: number): void {\n    if (\n      !Number.isInteger(cloneCount) ||\n      cloneCount < 0 ||\n      cloneCount > OptionsValidator.MAX_CLONES\n    ) {\n      throw new Error(\n        `MarqueeJS: cloneCount must be an integer between 0 and ${OptionsValidator.MAX_CLONES}`\n      );\n    }\n    this.options.cloneCount = cloneCount;\n    this.domManager?.createContentElements();\n    this.animationManager?.recalculatePositions();\n  }\n\n  public updateContainerHeight(containerHeight: number): void {\n    OptionsValidator.validateContainerHeight(containerHeight, this.options.direction);\n    this.options.containerHeight = containerHeight;\n\n    // Apply forced height for 'up' and 'down' directions\n    if ([\"up\", \"down\"].includes(this.options.direction!)) {\n      this.domManager?.updateContainerHeight(containerHeight);\n    }\n\n    this.animationManager?.recalculatePositions();\n    this.play();\n  }\n\n  public updatePauseOnHover(pauseOnHover: boolean): void {\n    this.options.pauseOnHover = pauseOnHover;\n    this.eventManager?.destroy();\n    this.eventManager = new EventManager(\n      this.element,\n      this.domManager?.getWrapper()!,\n      this.options,\n      {\n        pause: () => this.pause(),\n        resume: () => this.play(),\n      }\n    );\n  }\n\n  public recalculatePositions(): void {\n    this.animationManager?.recalculatePositions();\n    this.play();\n  }\n\n  public randomize(): void {\n    this.options.randomize = true;\n    this.reset();\n  }\n\n  public switchDirection(): void {\n    const oppositeDirection: Record<string, MarqueeOptions[\"direction\"]> = {\n      left: \"right\",\n      right: \"left\",\n      up: \"down\",\n      down: \"up\",\n    };\n\n    this.options.direction = oppositeDirection[this.options.direction!];\n  }\n\n  public async patchContent(\n    content: string | string[],\n    position: \"start\" | \"end\",\n    reset: boolean = false,\n    callback?: () => void\n  ): Promise<void> {\n    if (!content) return;\n    if (position !== \"start\" && position !== \"end\") {\n      throw new Error('MarqueeJS (patchContent): position must be either \"start\" or \"end\"');\n    }\n\n    if (reset) {\n      this.pause();\n    }\n\n    // Convert content to array if it's a string\n    const newContent = Array.isArray(content) ? content : [content];\n\n    // Validate new content\n    const validationResult = OptionsValidator.validateContentList(newContent, this.options);\n    if (!validationResult.isValid) {\n      console.warn(\n        \"MarqueeJS: Content validation failed:\",\n        validationResult.errors.map((e) => e.message).join(\", \")\n      );\n      return;\n    }\n\n    // If current content list is empty, just use the new content\n    if (!this.options.contentList?.length) {\n      this.options.contentList = newContent;\n    } else {\n      // If new content length is greater or equal to current content\n      // replace everything\n      if (newContent.length >= this.options.contentList.length) {\n        this.options.contentList = newContent;\n      } else {\n        // Otherwise patch at specified position\n        const currentContent = [...this.options.contentList];\n        if (position === \"start\") {\n          // Replace elements at start\n          currentContent.splice(0, newContent.length, ...newContent);\n        } else {\n          // Replace elements at end\n          const startIndex = currentContent.length - newContent.length;\n          currentContent.splice(startIndex, newContent.length, ...newContent);\n        }\n        this.options.contentList = currentContent;\n      }\n    }\n\n    if (reset) {\n      // Wait for reset to complete\n      await this.reset();\n    } else {\n      // Recreate content elements\n      this.domManager?.createContentElements();\n\n      // Recalculate positions and restart animation\n      this.animationManager?.recalculatePositions();\n    }\n\n    if (callback) {\n      requestAnimationFrame(() => {\n        callback();\n      });\n    }\n  }\n}\n","import { Marquee } from \"./core/Marquee\";\nimport type { MarqueeOptions, MarqueeInstance } from \"./types\";\n\nexport function marqueejs(selector: string, options: MarqueeOptions = {}): MarqueeInstance {\n  const instance = new Marquee(selector, options);\n\n  return {\n    start() {\n      instance.play();\n    },\n    stop() {\n      instance.pause();\n    },\n    pause() {\n      instance.pause();\n    },\n    resume() {\n      instance.play();\n    },\n    destroy() {\n      instance.destroy();\n    },\n    addContent(\n      content: string | string[],\n      addToStart: boolean = false,\n      reset: boolean = false,\n      callback?: () => void\n    ) {\n      instance.addContent(content, addToStart, reset, callback);\n    },\n    replaceContent(newContentList: string[], callback?: () => void) {\n      instance.replaceContent(newContentList, callback);\n    },\n    getContentList() {\n      return instance.getContentList();\n    },\n    updateSpeed(speed: number) {\n      instance.updateSpeed(speed);\n    },\n    updateGap(gap: number) {\n      instance.updateGap(gap);\n    },\n    updateSeparator(separator: string) {\n      instance.updateSeparator(separator);\n    },\n    updateCloneCount(cloneCount: number) {\n      instance.updateCloneCount(cloneCount);\n    },\n    updateContainerHeight(containerHeight: number) {\n      instance.updateContainerHeight(containerHeight);\n    },\n    updatePauseOnHover(pauseOnHover: boolean) {\n      instance.updatePauseOnHover(pauseOnHover);\n    },\n    recalculatePositions() {\n      instance.recalculatePositions();\n    },\n    randomize() {\n      instance.randomize();\n    },\n    switchDirection() {\n      instance.switchDirection();\n    },\n    patchContent(\n      content: string | string[],\n      position: \"start\" | \"end\",\n      reset: boolean = false,\n      callback?: () => void\n    ) {\n      instance.patchContent(content, position, reset, callback);\n    },\n  };\n}\n\nexport type { MarqueeOptions, MarqueeInstance };\n"],"names":["_OptionsValidator","options","validationResult","e","_","index","contentList","errors","validationOptions","_a","_b","_c","forbiddenTagsPattern","forbiddenAttrsPattern","attr","i","content","tag","speed","direction","validDirections","gap","containerHeight","keepOriginalContent","cloneCount","__publicField","OptionsValidator","AnimationManager","wrapper","groups","isHorizontal","currentPosition","group","size","position","animate","currentTime","deltaTime","movement","item","newPosition","currentElement","threshold","el","elementWidth","elementHeight","containerWidth","EventManager","_element","handlers","touchStartX","touchStartY","handleTouchMove","deltaX","deltaY","CloneCalculator","containerElement","contentElements","metrics","minClones","container","elements","containerSize","contentSize","total","DOMManager","element","elementClasses","elementId","originalHeight","fragment","temp","heights","rect","separatorOffset","totalSize","sum","m","offset","original","clone","style","height","Marquee","selector","validatedOptions","child","shuffledContent","j","resolve","newElement","addToStart","reset","callback","newContent","newContentList","separator","pauseOnHover","oppositeDirection","currentContent","startIndex","marqueejs","instance"],"mappings":"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"}