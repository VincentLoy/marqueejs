{"version":3,"file":"marqueejs.umd.min.js","sources":["../src/core/OptionsValidator.ts","../src/core/managers/PositionManager.ts","../src/core/managers/AnimationManager.ts","../src/core/managers/EventManager.ts","../src/core/managers/CloneCalculator.ts","../src/core/factories/ElementFactory.ts","../src/core/managers/SeparatorManager.ts","../src/core/managers/DOMManager.ts","../src/core/Marquee.ts","../src/index.ts"],"sourcesContent":["import type {\n  MarqueeOptions,\n  ContentValidationResult,\n  ContentValidationErrorType,\n  ContentValidationOptions,\n} from \"../types\";\n\nexport class OptionsValidator {\n  static readonly MAX_CLONES = 30;\n  static readonly MIN_CLONES = 0;\n  static readonly DEFAULT_MAX_LENGTH = 8500;\n\n  private static readonly FORBIDDEN_TAGS = [\n    \"script\",\n    \"style\",\n    \"iframe\",\n    \"object\",\n    \"embed\",\n    \"form\",\n    \"svg\",\n    \"input\",\n    \"button\",\n    \"meta\",\n    \"link\",\n    \"head\",\n    \"html\",\n    \"body\",\n  ];\n\n  private static readonly FORBIDDEN_ATTRIBUTES = [\n    \"onclick\",\n    \"onmouseover\",\n    \"onmouseout\",\n    \"onload\",\n    \"onerror\",\n    \"onsubmit\",\n    \"formaction\",\n    \"xlink:href\",\n    \"action\",\n    \"javascript\",\n  ];\n\n  private static readonly DEFAULT_VALIDATION_OPTIONS = {\n    maxLength: OptionsValidator.DEFAULT_MAX_LENGTH,\n    forbiddenTags: OptionsValidator.FORBIDDEN_TAGS,\n    forbiddenAttributes: OptionsValidator.FORBIDDEN_ATTRIBUTES,\n  } as const;\n\n  static validate(options: MarqueeOptions): MarqueeOptions {\n    this.validateSpeed(options.speed);\n    this.validateDirection(options.direction);\n    this.validateGap(options.gap);\n\n    // Initialize contentValidation with defaults if not provided\n    if (!options.contentValidation) {\n      options.contentValidation = this.DEFAULT_VALIDATION_OPTIONS;\n    } else {\n      options.contentValidation = {\n        maxLength: options.contentValidation.maxLength || this.DEFAULT_MAX_LENGTH,\n        forbiddenTags: [...this.FORBIDDEN_TAGS, ...(options.contentValidation.forbiddenTags || [])],\n        forbiddenAttributes: [\n          ...this.FORBIDDEN_ATTRIBUTES,\n          ...(options.contentValidation.forbiddenAttributes || []),\n        ],\n      };\n    }\n\n    // Add contentList validation\n    if (options.contentList) {\n      const validationResult = this.validateContentList(options.contentList, options);\n      if (!validationResult.isValid) {\n        console.warn(\n          \"MarqueeJS: Content list validation failed:\",\n          validationResult.errors.map((e) => e.message).join(\", \")\n        );\n        options.contentList = options.contentList.filter(\n          (_, index) => !validationResult.errors.some((e) => e.index === index)\n        );\n      }\n    }\n\n    // Handle clone count separately to return modified options\n    if (options.cloneCount !== undefined) {\n      if (options.cloneCount === \"auto\") {\n        // 'auto' est une valeur valide, ne rien faire\n      } else if (!Number.isInteger(options.cloneCount) || options.cloneCount < 0) {\n        console.warn(\n          `MarqueeJS: Requested ${options.cloneCount} clones, but minimum is ${this.MIN_CLONES}. Using ${this.MIN_CLONES} clones instead.`\n        );\n        options.cloneCount = this.MIN_CLONES;\n      } else if (typeof options.cloneCount === \"number\" && options.cloneCount > this.MAX_CLONES) {\n        console.warn(\n          `MarqueeJS: Requested ${options.cloneCount} clones, but maximum is ${this.MAX_CLONES}. Using ${this.MAX_CLONES} clones instead.`\n        );\n        options.cloneCount = this.MAX_CLONES;\n      }\n    }\n\n    // Remove separator for vertical directions\n    if ([\"up\", \"down\"].includes(options.direction || \"\") && options.separator) {\n      console.warn(\n        \"MarqueeJS: Separator is not supported for vertical directions. Separator will be ignored.\"\n      );\n      options.separator = \"\";\n    }\n\n    this.validateContainerHeight(options.containerHeight, options.direction);\n    this.validateKeepOriginalContent(options.keepOriginalContent);\n    this.validateContentValidationOptions(options.contentValidation);\n\n    return options;\n  }\n\n  public static validateContentList(\n    contentList: string[],\n    options: MarqueeOptions\n  ): ContentValidationResult {\n    const errors: {\n      type: ContentValidationErrorType;\n      message: string;\n      content?: string;\n      index?: number;\n    }[] = [];\n\n    if (!Array.isArray(contentList)) {\n      return {\n        isValid: false,\n        errors: [\n          {\n            type: \"INVALID_HTML\" as ContentValidationErrorType,\n            message: \"Content list must be an array of strings\",\n          },\n        ],\n      };\n    }\n\n    // Create a complete validation options object with all required properties\n    const validationOptions = {\n      ...this.DEFAULT_VALIDATION_OPTIONS,\n      ...options.contentValidation,\n      forbiddenTags: [...this.FORBIDDEN_TAGS, ...(options.contentValidation?.forbiddenTags || [])],\n      forbiddenAttributes: [\n        ...this.FORBIDDEN_ATTRIBUTES,\n        ...(options.contentValidation?.forbiddenAttributes || []),\n      ],\n      maxLength: options.contentValidation?.maxLength || this.DEFAULT_MAX_LENGTH,\n    };\n\n    const forbiddenTagsPattern = new RegExp(\n      `</?(?:${validationOptions.forbiddenTags.join(\"|\")})\\\\b[^>]*>`,\n      \"i\"\n    );\n    const forbiddenAttrsPattern = new RegExp(\n      validationOptions.forbiddenAttributes\n        .map((attr) => `${attr}\\\\s*=\\\\s*[\"']?[^\"']*[\"']?`)\n        .join(\"|\"),\n      \"i\"\n    );\n\n    for (let i = 0; i < contentList.length; i++) {\n      const content = contentList[i];\n\n      // Check for empty or non-string content\n      if (!content || typeof content !== \"string\") {\n        errors.push({\n          type: \"EMPTY_CONTENT\" as ContentValidationErrorType,\n          message: \"Content item must be a non-empty string\",\n          index: i,\n          content,\n        });\n        continue;\n      }\n\n      // Check for forbidden tags\n      if (forbiddenTagsPattern.test(content)) {\n        errors.push({\n          type: \"UNSAFE_TAG_DETECTED\" as ContentValidationErrorType,\n          message: \"Content contains forbidden HTML tags\",\n          index: i,\n          content: content.substring(0, 50) + \"...\",\n        });\n        continue;\n      }\n\n      // Check for forbidden attributes\n      if (forbiddenAttrsPattern.test(content)) {\n        errors.push({\n          type: \"UNSAFE_ATTRIBUTES\" as ContentValidationErrorType,\n          message: \"Content contains forbidden HTML attributes\",\n          index: i,\n          content: content.substring(0, 50) + \"...\",\n        });\n        continue;\n      }\n\n      // Check for user-defined or default length\n      if (content.length > validationOptions.maxLength) {\n        errors.push({\n          type: \"MAX_LENGTH_EXCEEDED\" as ContentValidationErrorType,\n          message: `Content item exceeds maximum length of ${validationOptions.maxLength} characters`,\n          index: i,\n          content: content.substring(0, 50) + \"...\",\n        });\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n\n  public static validateContentValidationOptions(\n    validationOptions: ContentValidationOptions\n  ): void {\n    if (\n      validationOptions.maxLength !== undefined &&\n      (typeof validationOptions.maxLength !== \"number\" || validationOptions.maxLength <= 0)\n    ) {\n      throw new Error(\"MarqueeJS: maxLength must be a positive number\");\n    }\n\n    if (\n      validationOptions.forbiddenTags !== undefined &&\n      (!Array.isArray(validationOptions.forbiddenTags) ||\n        validationOptions.forbiddenTags.some((tag) => typeof tag !== \"string\"))\n    ) {\n      throw new Error(\"MarqueeJS: forbiddenTags must be an array of strings\");\n    }\n\n    if (\n      validationOptions.forbiddenAttributes !== undefined &&\n      (!Array.isArray(validationOptions.forbiddenAttributes) ||\n        validationOptions.forbiddenAttributes.some((attr) => typeof attr !== \"string\"))\n    ) {\n      throw new Error(\"MarqueeJS: forbiddenAttributes must be an array of strings\");\n    }\n  }\n  public static validateSpeed(speed: number | undefined): void {\n    if (speed !== undefined && (typeof speed !== \"number\" || speed <= 0)) {\n      throw new Error(\"MarqueeJS: Speed must be a positive number\");\n    }\n  }\n\n  public static validateDirection(direction: string | undefined): void {\n    const validDirections = [\"left\", \"right\", \"up\", \"down\"];\n    if (direction && !validDirections.includes(direction)) {\n      throw new Error(`MarqueeJS: Direction must be one of: ${validDirections.join(\", \")}`);\n    }\n  }\n\n  public static validateGap(gap: number | undefined): void {\n    if (gap !== undefined && (typeof gap !== \"number\" || gap < 0)) {\n      throw new Error(\"MarqueeJS: Gap must be a non-negative number\");\n    }\n  }\n\n  public static validateContainerHeight(\n    containerHeight: number | undefined,\n    direction: string | undefined\n  ): void {\n    if (containerHeight !== undefined) {\n      if (typeof containerHeight !== \"number\" || containerHeight <= 0) {\n        throw new Error(\"MarqueeJS: Container height must be a positive number\");\n      }\n      if (![\"up\", \"down\"].includes(direction || \"\")) {\n        console.warn(\n          'MarqueeJS: Container height is only applicable for \"up\" and \"down\" directions. Ignoring containerHeight.'\n        );\n      }\n    }\n  }\n\n  public static validateKeepOriginalContent(keepOriginalContent: boolean | undefined): void {\n    if (keepOriginalContent !== undefined && typeof keepOriginalContent !== \"boolean\") {\n      throw new Error(\"MarqueeJS: keepOriginalContent must be a boolean\");\n    }\n  }\n\n  public static validateCloneCount(cloneCount: number | \"auto\"): void {\n    if (\n      cloneCount !== \"auto\" &&\n      (!Number.isInteger(cloneCount) || cloneCount < 0 || cloneCount > this.MAX_CLONES)\n    ) {\n      throw new Error(\n        `MarqueeJS: cloneCount must be 'auto' or an integer between ${this.MIN_CLONES} and ${this.MAX_CLONES}`\n      );\n    }\n  }\n}\n","import { MarqueeOptions, PositionedElement } from \"../../types\";\n\nexport class PositionManager {\n  /**\n   * Sets up initial positions for an array of HTML elements, either horizontally or vertically.\n   * Each element is positioned sequentially with a specified gap between them.\n   *\n   * @param elements - Array of HTMLElements to be positioned\n   * @param isHorizontal - If true, elements are positioned horizontally; if false, vertically\n   * @param gap - The spacing between elements in pixels\n   * @returns Array of {@link PositionedElement} containing each element and its position\n   *\n   * @example\n   * ```typescript\n   * const elements = document.querySelectorAll('.item');\n   * const positionedElements = PositionManager.setupElementsInitialPosition(\n   *   Array.from(elements),\n   *   true,\n   *   10\n   * );\n   * ```\n   */\n  public static setupElementsInitialPosition(\n    elements: HTMLElement[],\n    isHorizontal: boolean,\n    gap: number\n  ): Array<PositionedElement> {\n    let currentPosition = 0;\n    let maxSize = 0;\n\n    const positionedElements = elements.map((el): PositionedElement => {\n      const boudingRect = el.getBoundingClientRect();\n      const size = isHorizontal ? boudingRect.width + gap : boudingRect.height + gap;\n      const position = currentPosition;\n\n      PositionManager.positionElement(el, position, isHorizontal);\n\n      currentPosition += size;\n      maxSize = Math.max(maxSize, size);\n\n      return { el, position };\n    });\n\n    return positionedElements;\n  }\n  /**\n   * Positions an HTML element using absolute positioning and CSS transforms.\n   * @param element - The HTML element to position\n   * @param position - The position value in pixels\n   * @param isHorizontal - If true, positions horizontally (X axis). If false/undefined, positions vertically (Y axis)\n   * @returns void\n   */\n  public static positionElement(\n    element: HTMLElement,\n    position: number,\n    isHorizontal?: boolean\n  ): void {\n    if (!element) return;\n\n    element.style.position = \"absolute\";\n    element.style.willChange = \"transform\";\n    element.style.transform = isHorizontal\n      ? `translate3d(${position}px, 0, 0)`\n      : `translate3d(0, ${position}px, 0)`;\n  }\n\n  /**\n   * Positions a separator element relative to a target element with specified spacing and direction.\n   *\n   * @param target - The reference element to position the separator against\n   * @param separator - The separator HTML element to be positioned\n   * @param gap - The spacing between the target and separator in pixels\n   * @param isLeftDirection - If true, positions separator from the left; if false, positions from the right\n   *\n   * @remarks\n   * This method:\n   * - Sets absolute positioning for the separator\n   * - Aligns the separator vertically in the middle\n   * - Applies performance optimizations using will-change\n   * - Uses transform for vertical centering\n   */\n  public static positionSeparator(\n    target: Element,\n    separator: HTMLElement,\n    gap: number,\n    isLeftDirection: boolean\n  ): void {\n    const targetRect = target.getBoundingClientRect();\n    const separatorRect = separator.getBoundingClientRect();\n    const position = targetRect.width - separatorRect.width / 2 + gap / 2;\n\n    separator.style.position = \"absolute\";\n\n    if (isLeftDirection) {\n      separator.style.left = `${position}px`;\n    } else {\n      separator.style.right = `${position}px`;\n    }\n\n    separator.style.position = \"absolute\";\n    separator.style.top = \"50%\";\n    separator.style.lineHeight = \"0.70\";\n    separator.style.willChange = \"transform\";\n    separator.style.transform = \"translate3d(0, -50%, 0)\";\n  }\n\n  /**\n   * Determines if an element is the furthest positioned element in a given array based on direction\n   * @param item - Object containing the HTML element and its position\n   * @param elements - Array of positioned elements to compare against\n   * @param isHorizontal - Boolean indicating if the movement is horizontal\n   * @param direction - Direction of movement (\"left\", \"right\", \"up\", or \"down\")\n   * @returns Boolean indicating if the item is the furthest element in the specified direction\n   */\n  public static isFurthestElement(\n    item: {\n      el: HTMLElement;\n      position: number;\n    },\n    elements: Array<PositionedElement>,\n    isHorizontal: boolean,\n    direction: MarqueeOptions[\"direction\"]\n  ): boolean {\n    return !elements.some((other) => {\n      if (other === item) return false;\n      if (isHorizontal) {\n        return direction === \"left\"\n          ? item.position >= other.position\n          : item.position <= other.position;\n      } else {\n        return direction === \"up\"\n          ? item.position >= other.position\n          : item.position <= other.position;\n      }\n    });\n  }\n\n  /**\n   * Determines if a new position is available for an element without overlapping other elements.\n   *\n   * @param newPosition - The proposed position to check\n   * @param currentElement - The HTML element being positioned\n   * @param elements - Array of existing positioned elements with their positions\n   * @param gap - Minimum space required between elements\n   * @param isHorizontal - Direction of the marquee (true for horizontal, false for vertical)\n   * @returns True if the position is available, false if it would overlap with existing elements\n   *\n   * @remarks\n   * The function checks if placing an element at the new position would cause overlap with any existing\n   * elements, taking into account the specified gap between elements. It ignores collision checks with\n   * the current element itself.\n   */\n  public static isPositionAvailable(\n    newPosition: number,\n    currentElement: HTMLElement,\n    elements: Array<PositionedElement>,\n    gap: MarqueeOptions[\"gap\"],\n    isHorizontal: boolean\n  ): boolean {\n    const threshold = gap || 0;\n    return !elements.some(({ el, position }) => {\n      if (el === currentElement) return false;\n      const currentElSizeWatcher = isHorizontal\n        ? currentElement.offsetWidth\n        : currentElement.offsetHeight;\n      const elSizeWatcher = isHorizontal ? el.offsetWidth : el.offsetHeight;\n\n      return (\n        newPosition < position + elSizeWatcher + threshold &&\n        newPosition + currentElSizeWatcher > position - threshold\n      );\n    });\n  }\n\n  /**\n   * Updates the position of a given element within a marquee container.\n   *\n   * @param item - The element to be positioned with its current position data\n   * @param elements - Array of all positioned elements in the marquee\n   * @param wrapper - The HTML element wrapping all marquee elements\n   * @param movement - The amount of pixels to move the element by\n   * @param direction - The direction of movement (\"left\" | \"right\" | \"up\" | \"down\") type: <MarqueeDirectionValue>\n   * @param gap - The spacing between elements\n   *\n   * @remarks\n   * This method handles both horizontal and vertical movement.\n   * It calculates new positions based on the direction and checks if the element needs to be repositioned\n   * when it goes out of bounds. The actual position update only occurs if the new position is available\n   * and the element is the furthest in its direction of travel.\n   *\n   * The position is applied using CSS transform translate3d for better performance.\n   */\n  public static updatePosition(\n    item: PositionedElement,\n    elements: Array<PositionedElement>,\n    wrapper: HTMLElement,\n    movement: number,\n    direction: MarqueeOptions[\"direction\"],\n    gap: MarqueeOptions[\"gap\"]\n  ): void {\n    const isHorizontal = [\"left\", \"right\"].includes(direction!);\n    const wrapperRefSize = isHorizontal\n      ? wrapper.parentElement?.offsetWidth || 0\n      : wrapper.parentElement?.offsetHeight || 0;\n    const elementRefSize = isHorizontal ? item.el.offsetWidth + gap! : item.el.offsetHeight;\n    const isUpOrLeftDirection = [\"left\", \"up\"].includes(direction!);\n    let isFurthestElement = false;\n    let positionAvailable = false;\n    let newPosition = 0;\n\n    if (isUpOrLeftDirection) {\n      item.position -= movement;\n\n      if (item.position + elementRefSize < 0) {\n        newPosition = wrapperRefSize;\n      }\n    } else {\n      // here direction is right or down\n      item.position += movement;\n\n      const positionRef = isHorizontal ? item.position - gap! : item.position;\n\n      if (positionRef > wrapperRefSize) {\n        newPosition = -elementRefSize;\n      }\n    }\n\n    isFurthestElement = PositionManager.isFurthestElement(item, elements, isHorizontal, direction);\n    positionAvailable = PositionManager.isPositionAvailable(\n      newPosition,\n      item.el,\n      elements,\n      gap,\n      isHorizontal\n    );\n\n    if (positionAvailable && isFurthestElement && newPosition !== 0) {\n      item.position = newPosition;\n    }\n\n    if (isHorizontal) {\n      item.el.style.transform = `translate3d(${item.position}px, 0, 0)`;\n    } else {\n      item.el.style.transform = `translate3d(0, ${item.position}px, 0)`;\n    }\n  }\n}\n","import type { MarqueeOptions, PositionedElement } from \"../../types\";\nimport { PositionManager } from \"./PositionManager\";\n\nexport class AnimationManager {\n  private wrapper: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private animationFrame: number | null = null;\n  private lastTime: number = 0;\n  private elements: Array<PositionedElement> = [];\n  private isHorizontal: boolean;\n  public playing: boolean;\n\n  constructor(wrapper: HTMLElement, options: Partial<MarqueeOptions>) {\n    this.wrapper = wrapper;\n    this.options = options;\n    this.playing = false;\n    this.isHorizontal = [\"left\", \"right\"].includes(this.options.direction!);\n    this.setupElements();\n  }\n\n  /**\n   * Sets up the initial positions of the wrapper's child elements.\n   * This method processes all direct children of the wrapper element,\n   * positions them using the PositionManager, and stores them for animation.\n   *\n   * The positioning is done according to:\n   * - The horizontal/vertical orientation specified\n   * - The gap between elements defined in options\n   *\n   * @private\n   */\n  private setupElements(): void {\n    const groups = [...this.wrapper.children] as HTMLElement[];\n\n    const positionedElements = PositionManager.setupElementsInitialPosition(\n      groups,\n      this.isHorizontal,\n      this.options.gap!\n    );\n\n    this.elements = positionedElements;\n  }\n\n  /**\n   * Initiates the animation loop for the marquee.\n   * This method sets up a recursive animation frame request that:\n   * 1. Calculates the time delta between frames\n   * 2. Computes the movement distance based on speed and delta time\n   * 3. Updates the position of each element in the marquee\n   *\n   * The animation continues until {@link stopAnimation} is called.\n   *\n   * @remarks\n   * The animation uses requestAnimationFrame for smooth performance\n   * and calculates movement based on elapsed time to ensure\n   * consistent speed across different frame rates.\n   */\n  public startAnimation(): void {\n    this.lastTime = performance.now();\n    this.playing = true;\n\n    const animate = (currentTime: number) => {\n      const deltaTime = currentTime - this.lastTime;\n      this.lastTime = currentTime;\n      const movement = (this.options.speed! * deltaTime) / 1000;\n\n      // Update each element's position independently\n      this.elements.forEach((item) => {\n        PositionManager.updatePosition(\n          item,\n          this.elements,\n          this.wrapper,\n          movement,\n          this.options.direction!,\n          this.options.gap!\n        );\n      });\n\n      this.animationFrame = requestAnimationFrame(animate);\n    };\n\n    this.animationFrame = requestAnimationFrame(animate);\n  }\n\n  /**\n   * Stops the current animation by canceling the animation frame and resetting animation states.\n   * This method will:\n   * - Set the playing state to false\n   * - Cancel any existing animation frame\n   * - Reset the last recorded time\n   */\n  public stopAnimation(): void {\n    this.playing = false;\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n    this.lastTime = 0;\n  }\n\n  /**\n   * Recalculates positions of elements in the animation sequence.\n   * This method performs a complete reset of the animation by:\n   * 1. Stopping the current animation\n   * 2. Reinitializing element positions\n   * 3. Restarting the animation\n   */\n  public recalculatePositions(): void {\n    this.stopAnimation();\n    this.setupElements();\n    this.startAnimation();\n  }\n\n  /**\n   * Checks whether animations are currently being played.\n   * @returns {boolean} True if animations are playing, false otherwise.\n   */\n  public isPlaying(): boolean {\n    return this.playing;\n  }\n}\n","import type { MarqueeOptions } from \"../../types\";\n\nexport class EventManager {\n  private wrapper: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private handlers: {\n    pause: () => void;\n    resume: () => void;\n  };\n\n  constructor(\n    _element: HTMLElement,\n    wrapper: HTMLElement,\n    options: Partial<MarqueeOptions>,\n    handlers: { pause: () => void; resume: () => void }\n  ) {\n    this.wrapper = wrapper;\n    this.options = options;\n    this.handlers = handlers;\n    this.init();\n  }\n\n  private init(): void {\n    this.setupHoverEvents();\n    this.setupTouchEvents();\n    this.setupVisibilityEvents();\n  }\n\n  private setupHoverEvents(): void {\n    if (this.options.pauseOnHover) {\n      this.wrapper.addEventListener(\"mouseenter\", this.handlers.pause);\n      this.wrapper.addEventListener(\"mouseleave\", this.handlers.resume);\n    }\n  }\n\n  private setupTouchEvents(): void {\n    let touchStartX: number;\n    let touchStartY: number;\n\n    // Add passive touch start listener\n    this.wrapper.addEventListener(\n      \"touchstart\",\n      (e: TouchEvent) => {\n        touchStartX = e.touches[0].clientX;\n        touchStartY = e.touches[0].clientY;\n        this.handlers.pause();\n      },\n      { passive: true }\n    );\n\n    // Add passive touch end listener\n    this.wrapper.addEventListener(\n      \"touchend\",\n      () => {\n        this.handlers.resume();\n      },\n      { passive: true }\n    );\n\n    // Separate touch move handler that can prevent default\n    const handleTouchMove = (e: TouchEvent) => {\n      const deltaX = e.touches[0].clientX - touchStartX;\n      const deltaY = e.touches[0].clientY - touchStartY;\n\n      if (\n        Math.abs(deltaX) > Math.abs(deltaY) &&\n        [\"left\", \"right\"].includes(this.options.direction!)\n      ) {\n        e.preventDefault();\n      } else if (\n        Math.abs(deltaY) > Math.abs(deltaX) &&\n        [\"up\", \"down\"].includes(this.options.direction!)\n      ) {\n        e.preventDefault();\n      }\n    };\n\n    // Add non-passive touch move listener only when needed\n    if ([\"left\", \"right\", \"up\", \"down\"].includes(this.options.direction!)) {\n      this.wrapper.addEventListener(\"touchmove\", handleTouchMove, {\n        passive: false,\n      });\n    } else {\n      this.wrapper.addEventListener(\"touchmove\", handleTouchMove, {\n        passive: true,\n      });\n    }\n  }\n\n  private setupVisibilityEvents(): void {\n    document.addEventListener(\"visibilitychange\", () => {\n      if (document.hidden) {\n        this.handlers.pause();\n      } else {\n        this.handlers.resume();\n      }\n    });\n  }\n\n  public destroy(): void {\n    if (this.options.pauseOnHover) {\n      this.wrapper.removeEventListener(\"mouseenter\", this.handlers.pause);\n      this.wrapper.removeEventListener(\"mouseleave\", this.handlers.resume);\n    }\n\n    this.wrapper.removeEventListener(\"touchstart\", this.handlers.pause);\n    this.wrapper.removeEventListener(\"touchend\", this.handlers.resume);\n    document.removeEventListener(\"visibilitychange\", this.handlers.pause);\n  }\n}\n","import type { CloneMetrics, MarqueeOptions } from \"../../types\";\n\nexport class CloneCalculator {\n  private cachedMetrics: CloneMetrics | null = null;\n\n  constructor(private direction: Partial<MarqueeOptions[\"direction\"]>) {}\n\n  /**\n   * Calculates the optimal number of clones needed for smooth infinite scrolling.\n   *\n   * This method determines the minimum number of element clones required to ensure\n   * continuous scrolling based on the container and content dimensions.\n   * It includes caching optimization to avoid recalculation when metrics haven't changed.\n   *\n   * @param containerElement - The HTML element that serves as the scrolling container\n   * @param contentElements - Array of HTML elements representing the content to be cloned\n   * @param gap - The spacing between content elements in pixels\n   * @returns The minimum number of clones needed for continuous scrolling\n   *\n   * @example\n   * const cloneCount = calculator.calculateOptimalCloneCount(container, items, 10);\n   */\n  public calculateOptimalCloneCount(\n    containerElement: HTMLElement,\n    contentElements: HTMLElement[],\n    gap: number\n  ): number {\n    const isHorizontal = [\"left\", \"right\"].includes(this.direction!);\n\n    const metrics = this.calculateMetrics(containerElement, contentElements, gap, isHorizontal);\n\n    // If metrics are identical, return from cache\n    if (\n      this.cachedMetrics &&\n      this.cachedMetrics.containerSize === metrics.containerSize &&\n      this.cachedMetrics.contentSize === metrics.contentSize\n    ) {\n      return this.cachedMetrics.calculatedCount;\n    }\n\n    // Calculate minimum number of clones needed\n    // (+1 to ensure continuous scrolling)\n    const minClones = Math.ceil(metrics.containerSize / metrics.contentSize) + 1;\n\n    // Cache the new metrics\n    this.cachedMetrics = {\n      ...metrics,\n      calculatedCount: minClones,\n    };\n\n    return minClones;\n  }\n\n  /**\n   * Calculates the size metrics for a container and its elements\n   * @param container - The HTML container element to measure\n   * @param elements - Array of HTML elements inside the container to measure\n   * @param gap - The gap size between elements\n   * @param isHorizontal - Boolean flag indicating if the layout is horizontal (true) or vertical (false)\n   * @returns An object containing the container size and total content size (including gaps)\n   * @private\n   */\n  private calculateMetrics(\n    container: HTMLElement,\n    elements: HTMLElement[],\n    gap: number,\n    isHorizontal: boolean\n  ): Omit<CloneMetrics, \"calculatedCount\"> {\n    const containerSize = isHorizontal ? container.offsetWidth : container.offsetHeight;\n\n    const contentSize = elements.reduce((total, el) => {\n      const size = isHorizontal ? el.offsetWidth : el.offsetHeight;\n      return total + size + gap;\n    }, 0);\n\n    return {\n      containerSize,\n      contentSize,\n    };\n  }\n\n  /**\n   * Invalidates the cached metrics by setting them to null.\n   * This forces a recalculation of metrics the next time they are requested.\n   */\n  public invalidateCache(): void {\n    this.cachedMetrics = null;\n  }\n}\n","/**\n * Factory class responsible for creating and configuring DOM elements for the marquee component.\n *\n * @class ElementFactory\n *\n * @property {string} instanceId - Unique identifier for the marquee instance\n * @property {Partial<MarqueeOptions>} options - Configuration options for the marquee\n * @property {HTMLElement} element - The base HTML element to transform into a marquee\n * @property {boolean} isHorizontal - Indicates if the marquee scrolls horizontally\n */\nexport class ElementFactory {\n  /**\n   * Creates a container element for the marquee\n   *\n   * @returns {HTMLElement} - The container element\n   */\n  public static createContainer(element: HTMLElement, instanceId: string): HTMLElement {\n    const container = document.createElement(\"div\");\n    const elementClasses = Array.from(element.classList);\n    const elementId = element.id?.length ? element.id : undefined;\n\n    container.classList.add(instanceId, \"marquee-container\");\n    container.classList.add(...elementClasses);\n\n    if (elementId) {\n      container.id = elementId;\n    }\n\n    container.style.width = \"100%\";\n    container.style.overflow = \"hidden\";\n\n    return container;\n  }\n\n  /**\n   * Creates and configures an HTMLElement to serve as a wrapper for the marquee content.\n   *\n   * @returns {HTMLElement} A configured div element serving as the marquee wrapper\n   */\n  public static createWrapper(isHorizontal: boolean): HTMLElement {\n    const wrapper = document.createElement(\"div\");\n    wrapper.classList.add(\"marquee-wrapper\");\n    wrapper.style.position = \"relative\";\n    wrapper.style.width = \"100%\";\n    wrapper.style.height = \"100%\";\n    wrapper.style.overflow = \"visible\";\n    wrapper.style.display = isHorizontal ? \"flex\" : \"block\";\n\n    if (isHorizontal) {\n      wrapper.style.alignItems = \"center\";\n    }\n\n    return wrapper;\n  }\n\n  /**\n   * Creates a new HTMLElement to contain marquee content.\n   *\n   * @param content - The string content to be displayed inside the marquee element\n   * @returns An HTMLElement configured with the appropriate styling and content\n   */\n  public static createContentElement(content: string, isHorizontal: boolean): HTMLElement {\n    const element = document.createElement(\"div\");\n    const contentEl = document.createElement(\"div\");\n    element.className = \"marquee-content-item\";\n    contentEl.classList.add(\"marquee-content\");\n    element.style.position = \"absolute\";\n    element.style.whiteSpace = !isHorizontal ? \"normal\" : \"nowrap\";\n    element.style.width = !isHorizontal ? \"100%\" : \"auto\";\n    element.appendChild(contentEl);\n    contentEl.innerHTML = content;\n    return element;\n  }\n\n  /**\n   * Creates and configures a separator element for the marquee.\n   * The separator element is a span that contains the configured separator content\n   * and styles.\n   *\n   * @returns {HTMLElement} A new span element configured as a marquee separator\n   */\n  public static createSeparatorElement(theSeparator: string, separatorStyles: string): HTMLElement {\n    const separator = document.createElement(\"span\");\n    separator.className = \"marquee-separator\";\n    separator.innerHTML = `<span style=\"display: inline-block; ${separatorStyles}\">${theSeparator}</span>`;\n    separator.style.whiteSpace = \"pre\";\n    return separator;\n  }\n}\n","import { MarqueeOptions } from \"../../types\";\nimport { ElementFactory } from \"../factories/ElementFactory\";\nimport { PositionManager } from \"./PositionManager\";\n\nexport class SeparatorManager {\n  private wrapper: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private isHorizontal: boolean;\n\n  constructor(options: Partial<MarqueeOptions>, wrapper: HTMLElement) {\n    this.options = options;\n    this.wrapper = wrapper;\n    this.isHorizontal = [\"left\", \"right\"].includes(options.direction!);\n  }\n\n  /**\n   * Updates the separator elements between marquee content items.\n   * If no separator is defined in options or if the marquee is not horizontal direction, the method returns early.\n   * This method first removes all existing separators and then creates new ones between each content item.\n   * The separators are positioned based on the direction (left/right) and gap settings from the options.\n   *\n   * @remarks\n   * This method is responsible for:\n   * - Cleaning up existing separator elements\n   * - Creating new separator elements between items\n   * - Positioning separators according to direction and gap settings\n   *\n   * @throws {Error} Implicitly may throw if DOM operations fail\n   */\n  public updateSeparators(): void {\n    if (!this.options.separator || !this.isHorizontal) return;\n\n    this.cleanupSeparatorElements();\n    const elements = this.wrapper.querySelectorAll(\".marquee-content-item\");\n    const isLeftDirection = this.options.direction === \"left\";\n\n    // Create new separators between items\n    elements.forEach((el) => {\n      const separator = ElementFactory.createSeparatorElement(\n        this.options.separator!,\n        this.options.separatorStyles!\n      );\n      el.appendChild(separator);\n      PositionManager.positionSeparator(el, separator, this.options.gap!, isLeftDirection);\n    });\n  }\n\n  /**\n   * Removes all separator elements from the DOM that have the 'marquee-separator' class.\n   * @returns {void}\n   */\n  public cleanupSeparatorElements(): void {\n    const separators = this.wrapper.querySelectorAll(\".marquee-separator\");\n    separators?.forEach((separator) => separator.remove());\n  }\n}\n","import type { MarqueeOptions, ElementMetrics } from \"../../types\";\nimport { CloneCalculator } from \"./CloneCalculator\";\nimport { ElementFactory } from \"../factories/ElementFactory\";\nimport { SeparatorManager } from \"./SeparatorManager\";\nimport { PositionManager } from \"./PositionManager\";\n\nexport class DOMManager {\n  private container: HTMLElement;\n  private wrapper: HTMLElement;\n  private element: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private contentElements: HTMLElement[] = [];\n  private clones: HTMLElement[] = [];\n  private instanceId: string;\n  private cloneCalculator: CloneCalculator;\n  private isHorizontal: boolean;\n  private separatorManager: SeparatorManager;\n\n  constructor(element: HTMLElement, options: Partial<MarqueeOptions>) {\n    this.isHorizontal = [\"left\", \"right\"].includes(options.direction!);\n    this.instanceId = `marquee-${Math.random().toString(36).substring(2, 9)}`;\n    this.element = element;\n    this.options = options;\n    this.container = ElementFactory.createContainer(this.element, this.instanceId);\n    this.wrapper = ElementFactory.createWrapper(this.isHorizontal);\n    this.separatorManager = new SeparatorManager(this.options, this.wrapper);\n    this.cloneCalculator = new CloneCalculator(options.direction!);\n    // Clear original element since everything goes through contentList\n    this.element.innerHTML = \"\";\n\n    this.setupDOM();\n  }\n\n  public setupDOM(): void {\n    const originalHeight = this.getMaxContentHeight();\n\n    // Configure container height\n    if (!this.isHorizontal && this.options.containerHeight) {\n      this.container.style.height = `${this.options.containerHeight}px`;\n    } else {\n      this.container.style.height = `${originalHeight}px`;\n    }\n\n    // Insert into DOM\n    this.element.parentNode?.insertBefore(this.container, this.element);\n    this.container.appendChild(this.wrapper);\n\n    // Create content elements from contentList\n    this.createContentElements();\n  }\n\n  public async createContentElements(): Promise<void> {\n    // Clear existing elements\n    this.clearElements();\n\n    const fragment = document.createDocumentFragment();\n    this.options.contentList!.forEach((content) => {\n      const element = ElementFactory.createContentElement(content, this.isHorizontal);\n      this.contentElements.push(element);\n      fragment.appendChild(element);\n    });\n\n    this.wrapper.appendChild(fragment);\n    this.positionElements();\n    await this.createClones();\n\n    // Add separator styles after creating elements\n    this.updateSeparators();\n  }\n\n  private clearElements(): void {\n    this.contentElements.forEach((el) => el.remove());\n    this.clones.forEach((el) => el.remove());\n    this.contentElements = [];\n    this.clones = [];\n  }\n\n  private getMaxContentHeight(): number {\n    const temp = document.createElement(\"div\");\n    const heightSecurityMargin = this.options.heightSecurityMargin || 0;\n    temp.style.position = \"absolute\";\n    temp.style.visibility = \"hidden\";\n    temp.style.left = \"-9999px\";\n    document.body.appendChild(temp);\n\n    const heights = this.options.contentList!.map((content) => {\n      temp.innerHTML = content;\n      return temp.offsetHeight + heightSecurityMargin;\n    });\n\n    document.body.removeChild(temp);\n    return Math.max(...heights, 0);\n  }\n\n  private calculateMetrics(): ElementMetrics[] {\n    const isHorizontal = this.isHorizontal;\n    const metrics: ElementMetrics[] = [];\n    let currentPosition = 0;\n\n    this.contentElements.forEach((el) => {\n      const rect = el.getBoundingClientRect();\n      const size = isHorizontal ? rect.width : rect.height;\n\n      metrics.push({\n        size,\n        spacing: this.options.gap!,\n        position: currentPosition,\n      });\n\n      currentPosition += size + this.options.gap!;\n    });\n\n    return metrics;\n  }\n\n  private positionElements(): void {\n    const metrics = this.calculateMetrics();\n    this.contentElements.forEach((el, i) => {\n      const { position } = metrics[i];\n      PositionManager.positionElement(el, position, this.isHorizontal);\n    });\n  }\n\n  private async createClones(): Promise<void> {\n    // If cloneCount is 'auto', use CloneCalculator\n    const cloneCount =\n      this.options.cloneCount === \"auto\"\n        ? this.cloneCalculator.calculateOptimalCloneCount(\n            this.container,\n            this.contentElements,\n            this.options.gap!\n          )\n        : this.options.cloneCount!;\n\n    if (cloneCount! <= 0) return;\n\n    const metrics = this.calculateMetrics();\n    const totalSize = metrics.reduce((sum, m) => sum + m.size + m.spacing, 0);\n    const fragment = document.createDocumentFragment();\n\n    for (let i = 0; i < cloneCount; i++) {\n      const offset = totalSize * (i + 1);\n      this.contentElements.forEach((original, index) => {\n        const clone = original.cloneNode(true) as HTMLElement;\n        clone.setAttribute(\"aria-hidden\", \"true\");\n        clone.classList.add(\"marquee-cloned-item\");\n\n        PositionManager.positionElement(clone, metrics[index].position + offset, this.isHorizontal);\n\n        this.clones.push(clone);\n        fragment.appendChild(clone);\n      });\n    }\n\n    this.wrapper.appendChild(fragment);\n  }\n\n  // Utility method to force recalculation of clones\n  public recalculateClones(): void {\n    this.cloneCalculator.invalidateCache();\n    this.createContentElements();\n  }\n\n  public updateContainerHeight(height: number): void {\n    if (this.container) {\n      this.container.style.height = `${height}px`;\n    }\n  }\n\n  public getWrapper(): HTMLElement {\n    return this.wrapper;\n  }\n\n  public getContainer(): HTMLElement {\n    return this.container;\n  }\n\n  public getContentElements(): HTMLElement[] {\n    return this.contentElements;\n  }\n\n  public updateSeparators(): void {\n    this.separatorManager.updateSeparators();\n  }\n\n  public destroy(): void {\n    this.clearElements();\n    if (this.wrapper.parentNode) {\n      this.wrapper.parentNode.insertBefore(this.element, this.wrapper);\n      this.container.remove();\n    }\n\n    document.querySelector(`.${this.instanceId}`)?.remove();\n  }\n}\n","import type { MarqueeOptions } from \"../types\";\nimport { OptionsValidator } from \"./OptionsValidator\";\nimport { AnimationManager } from \"./managers/AnimationManager\";\nimport { EventManager } from \"./managers/EventManager\";\nimport { DOMManager } from \"./managers/DOMManager\";\n\nexport class Marquee {\n  private element!: HTMLElement;\n  private originalElement: HTMLElement;\n  private options!: Partial<MarqueeOptions>;\n  private isPlaying: boolean = false;\n  private animationManager: AnimationManager | null = null;\n  private eventManager: EventManager | null = null;\n  private domManager: DOMManager | null = null;\n  private htmlContentList: string[] = [];\n\n  private defaultOptions: Partial<MarqueeOptions> = {\n    speed: 100,\n    direction: \"left\",\n    pauseOnHover: false,\n    gap: 20,\n    cloneCount: \"auto\",\n    separator: \"\",\n    separatorStyles: \"\",\n    randomize: false,\n    contentList: [],\n    startAfter: 0,\n    heightSecurityMargin: 0,\n  };\n\n  constructor(selector: string | HTMLElement, options: MarqueeOptions = {}) {\n    const element = typeof selector === \"string\" ? document.querySelector(selector) : selector;\n\n    if (!element) {\n      throw new Error(\"Invalid element selector\");\n    }\n\n    // Store a deep copy of the original element\n    this.originalElement = element.cloneNode(true) as HTMLElement;\n    this.setupInstance(element as HTMLElement, options);\n    this.init();\n  }\n\n  private setupInstance(element: HTMLElement, options: MarqueeOptions): void {\n    const validatedOptions = OptionsValidator.validate(options);\n    this.element = element;\n    this.options = { ...this.defaultOptions, ...validatedOptions };\n    this.htmlContentList = Array.from(this.element.children).map((child) => child.outerHTML);\n\n    // If contentList is empty, populate it with the direct children of the marquee element\n    if (!this.options.contentList?.length) {\n      this.options.contentList = this.htmlContentList;\n    } else if (this.htmlContentList.length && this.options.keepOriginalContent) {\n      // If contentList is not empty, but the original content should be kept, append it to the contentList\n      this.options.contentList = [...this.htmlContentList, ...this.options.contentList];\n    }\n\n    // Randomize contentList if required\n    if (this.options.randomize) {\n      this.options.contentList = this.randomizeContent();\n    }\n  }\n\n  private async init(): Promise<void> {\n    // Cleanup existing managers if they exist\n    this.destroy();\n\n    this.domManager = new DOMManager(this.element, this.options);\n    this.domManager.createContentElements();\n\n    const wrapper = this.domManager.getWrapper();\n    const contentElements = this.domManager.getContentElements();\n\n    if (wrapper && contentElements.length > 0) {\n      this.animationManager = new AnimationManager(wrapper, this.options);\n      this.eventManager = new EventManager(this.element, wrapper, this.options, {\n        pause: () => this.pause(),\n        resume: () => this.play(),\n      });\n\n      setTimeout(() => {\n        this.play();\n      }, this.options.startAfter);\n    }\n  }\n\n  private randomizeContent(): string[] {\n    const shuffledContent = [...this.options.contentList!];\n    for (let i = shuffledContent.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffledContent[i], shuffledContent[j]] = [shuffledContent[j], shuffledContent[i]];\n    }\n    return shuffledContent;\n  }\n\n  public async reset(): Promise<void> {\n    return new Promise<void>(async (resolve) => {\n      // Stop current animation\n      this.pause();\n\n      // Recreate element from original\n      const newElement = this.originalElement.cloneNode(true) as HTMLElement;\n\n      // Replace old element with new one\n      if (this.element.parentElement) {\n        this.element.parentElement.replaceChild(newElement, this.element);\n      }\n\n      // Wait for cleanup to complete\n      await Promise.resolve(this.destroy());\n\n      // Completely reset the instance\n      this.setupInstance(newElement, this.options);\n\n      // Wait for initialization to complete\n      await this.init();\n\n      resolve();\n    });\n  }\n\n  public destroy(): Promise<void> {\n    return new Promise<void>((resolve) => {\n      this.pause();\n      this.animationManager?.stopAnimation();\n      this.eventManager?.destroy();\n      this.domManager?.destroy();\n\n      // S'assurer que le DOM a eu le temps de se mettre Ã  jour\n      requestAnimationFrame(() => {\n        resolve();\n      });\n    });\n  }\n\n  public play(): void {\n    if (this.isPlaying) return;\n    this.isPlaying = true;\n    this.startAnimation();\n  }\n\n  public pause(): void {\n    if (!this.isPlaying) return;\n    this.isPlaying = false;\n    this.stopAnimation();\n  }\n\n  private startAnimation(): void {\n    this.animationManager?.startAnimation();\n  }\n\n  private stopAnimation(): void {\n    this.animationManager?.stopAnimation();\n  }\n\n  public async addContent(\n    content: string | string[],\n    addToStart: boolean = false,\n    reset: boolean = false,\n    callback?: () => void\n  ): Promise<void> {\n    if (!content) return;\n\n    if (reset) {\n      this.pause();\n    }\n\n    // Convert content to array if it's a string\n    const newContent = Array.isArray(content) ? content : [content];\n\n    // Validate new content\n    const validationResult = OptionsValidator.validateContentList(newContent, this.options);\n    if (!validationResult.isValid) {\n      console.warn(\n        \"MarqueeJS: Content validation failed:\",\n        validationResult.errors.map((e) => e.message).join(\", \")\n      );\n      return;\n    }\n\n    // Add new content to the contentList\n    if (addToStart) {\n      this.options.contentList = [...newContent, ...this.options.contentList!];\n    } else {\n      this.options.contentList = [...this.options.contentList!, ...newContent];\n    }\n\n    if (reset) {\n      // Wait for reset to complete\n      await this.reset();\n    } else {\n      // Recreate content elements\n      this.domManager?.createContentElements();\n\n      // Recalculate positions and restart animation\n      this.animationManager?.recalculatePositions();\n    }\n\n    if (callback) {\n      requestAnimationFrame(() => {\n        callback();\n      });\n    }\n  }\n\n  public replaceContent(newContentList: string[], callback?: () => void): void {\n    if (!Array.isArray(newContentList)) return;\n\n    // Validate new content list\n    const validationResult = OptionsValidator.validateContentList(newContentList, this.options);\n    if (!validationResult.isValid) {\n      console.warn(\n        \"MarqueeJS: Content validation failed:\",\n        validationResult.errors.map((e) => e.message).join(\", \")\n      );\n      return;\n    }\n\n    // Replace the contentList with the new one\n    this.options.contentList = newContentList;\n\n    // Recreate content elements\n    this.domManager?.createContentElements();\n\n    // Recalculate positions and restart animation\n    this.animationManager?.recalculatePositions();\n\n    if (callback) {\n      requestAnimationFrame(() => {\n        callback();\n      });\n    }\n  }\n\n  public getContentList(): string[] {\n    return this.options.contentList!;\n  }\n\n  public updateSpeed(speed: number): void {\n    OptionsValidator.validateSpeed(speed);\n    this.options.speed = speed;\n  }\n\n  public updateGap(gap: number): void {\n    OptionsValidator.validateGap(gap);\n    this.options.gap = gap;\n    this.domManager?.createContentElements();\n    this.animationManager?.recalculatePositions();\n  }\n\n  public updateSeparator(separator: string): void {\n    this.options.separator = separator;\n    this.domManager?.createContentElements();\n    this.animationManager?.recalculatePositions();\n  }\n\n  public updateSeparatorStyles(styles: string): void {\n    this.options.separatorStyles = styles;\n    this.domManager?.updateSeparators();\n  }\n\n  public updateCloneCount(cloneCount: number): void {\n    if (\n      !Number.isInteger(cloneCount) ||\n      cloneCount < 0 ||\n      cloneCount > OptionsValidator.MAX_CLONES\n    ) {\n      throw new Error(\n        `MarqueeJS: cloneCount must be an integer between 0 and ${OptionsValidator.MAX_CLONES}`\n      );\n    }\n    this.options.cloneCount = cloneCount;\n    this.domManager?.createContentElements();\n    this.animationManager?.recalculatePositions();\n  }\n\n  public updateContainerHeight(containerHeight: number): void {\n    OptionsValidator.validateContainerHeight(containerHeight, this.options.direction);\n    this.options.containerHeight = containerHeight;\n\n    // Apply forced height for 'up' and 'down' directions\n    if ([\"up\", \"down\"].includes(this.options.direction!)) {\n      this.domManager?.updateContainerHeight(containerHeight);\n    }\n\n    this.animationManager?.recalculatePositions();\n    this.play();\n  }\n\n  public updatePauseOnHover(pauseOnHover: boolean): void {\n    this.options.pauseOnHover = pauseOnHover;\n    this.eventManager?.destroy();\n    this.eventManager = new EventManager(\n      this.element,\n      this.domManager?.getWrapper()!,\n      this.options,\n      {\n        pause: () => this.pause(),\n        resume: () => this.play(),\n      }\n    );\n  }\n\n  public recalculatePositions(): void {\n    this.animationManager?.recalculatePositions();\n    this.play();\n  }\n\n  public randomize(): void {\n    this.options.randomize = true;\n    this.reset();\n  }\n\n  public switchDirection(): void {\n    const oppositeDirection: Record<string, MarqueeOptions[\"direction\"]> = {\n      left: \"right\",\n      right: \"left\",\n      up: \"down\",\n      down: \"up\",\n    };\n\n    this.options.direction = oppositeDirection[this.options.direction!];\n  }\n\n  public async patchContent(\n    content: string | string[],\n    position: \"start\" | \"end\",\n    reset: boolean = false,\n    callback?: () => void\n  ): Promise<void> {\n    if (!content) return;\n    if (position !== \"start\" && position !== \"end\") {\n      throw new Error('MarqueeJS (patchContent): position must be either \"start\" or \"end\"');\n    }\n\n    if (reset) {\n      this.pause();\n    }\n\n    // Convert content to array if it's a string\n    const newContent = Array.isArray(content) ? content : [content];\n\n    // Validate new content\n    const validationResult = OptionsValidator.validateContentList(newContent, this.options);\n    if (!validationResult.isValid) {\n      console.warn(\n        \"MarqueeJS: Content validation failed:\",\n        validationResult.errors.map((e) => e.message).join(\", \")\n      );\n      return;\n    }\n\n    // If current content list is empty, just use the new content\n    if (!this.options.contentList?.length) {\n      this.options.contentList = newContent;\n    } else {\n      // If new content length is greater or equal to current content\n      // replace everything\n      if (newContent.length >= this.options.contentList.length) {\n        this.options.contentList = newContent;\n      } else {\n        // Otherwise patch at specified position\n        const currentContent = [...this.options.contentList];\n        if (position === \"start\") {\n          // Replace elements at start\n          currentContent.splice(0, newContent.length, ...newContent);\n        } else {\n          // Replace elements at end\n          const startIndex = currentContent.length - newContent.length;\n          currentContent.splice(startIndex, newContent.length, ...newContent);\n        }\n        this.options.contentList = currentContent;\n      }\n    }\n\n    if (reset) {\n      // Wait for reset to complete\n      await this.reset();\n    } else {\n      // Recreate content elements\n      this.domManager?.createContentElements();\n\n      // Recalculate positions and restart animation\n      this.animationManager?.recalculatePositions();\n    }\n\n    if (callback) {\n      requestAnimationFrame(() => {\n        callback();\n      });\n    }\n  }\n}\n","import { Marquee } from \"./core/Marquee\";\nimport type { MarqueeOptions, MarqueeInstance } from \"./types\";\n\nexport function marqueejs(selector: string, options: MarqueeOptions = {}): MarqueeInstance {\n  const instance = new Marquee(selector, options);\n\n  return {\n    pause() {\n      instance.pause();\n    },\n    resume() {\n      instance.play();\n    },\n    destroy() {\n      instance.destroy();\n    },\n    addContent(\n      content: string | string[],\n      addToStart: boolean = false,\n      reset: boolean = false,\n      callback?: () => void\n    ) {\n      instance.addContent(content, addToStart, reset, callback);\n    },\n    replaceContent(newContentList: string[], callback?: () => void) {\n      instance.replaceContent(newContentList, callback);\n    },\n    getContentList() {\n      return instance.getContentList();\n    },\n    updateSpeed(speed: number) {\n      instance.updateSpeed(speed);\n    },\n    updateGap(gap: number) {\n      instance.updateGap(gap);\n    },\n    updateSeparator(separator: string) {\n      instance.updateSeparator(separator);\n    },\n    updateSeparatorStyles(styles: string) {\n      instance.updateSeparatorStyles(styles);\n    },\n    updateCloneCount(cloneCount: number) {\n      instance.updateCloneCount(cloneCount);\n    },\n    updateContainerHeight(containerHeight: number) {\n      instance.updateContainerHeight(containerHeight);\n    },\n    updatePauseOnHover(pauseOnHover: boolean) {\n      instance.updatePauseOnHover(pauseOnHover);\n    },\n    recalculatePositions() {\n      instance.recalculatePositions();\n    },\n    randomize() {\n      instance.randomize();\n    },\n    switchDirection() {\n      instance.switchDirection();\n    },\n    patchContent(\n      content: string | string[],\n      position: \"start\" | \"end\",\n      reset: boolean = false,\n      callback?: () => void\n    ) {\n      instance.patchContent(content, position, reset, callback);\n    },\n  };\n}\n\nexport type { MarqueeOptions, MarqueeInstance };\n"],"names":["g","f","exports","_OptionsValidator","options","validationResult","e","_","index","contentList","_a","_b","_c","errors","validationOptions","forbiddenTagsPattern","forbiddenAttrsPattern","attr","i","content","tag","speed","direction","validDirections","gap","containerHeight","keepOriginalContent","cloneCount","__publicField","OptionsValidator","PositionManager","elements","isHorizontal","currentPosition","el","boudingRect","size","position","element","target","separator","isLeftDirection","targetRect","separatorRect","item","other","newPosition","currentElement","threshold","currentElSizeWatcher","elSizeWatcher","wrapper","movement","wrapperRefSize","elementRefSize","isUpOrLeftDirection","isFurthestElement","positionAvailable","AnimationManager","groups","positionedElements","animate","currentTime","deltaTime","EventManager","_element","handlers","touchStartX","touchStartY","handleTouchMove","deltaX","deltaY","CloneCalculator","containerElement","contentElements","metrics","minClones","container","containerSize","contentSize","total","ElementFactory","instanceId","elementClasses","elementId","contentEl","theSeparator","separatorStyles","SeparatorManager","separators","DOMManager","originalHeight","fragment","temp","heightSecurityMargin","heights","rect","totalSize","sum","m","offset","original","clone","height","Marquee","selector","validatedOptions","child","shuffledContent","j","resolve","newElement","addToStart","reset","callback","newContent","newContentList","styles","pauseOnHover","oppositeDirection","currentContent","startIndex","marqueejs","instance"],"mappings":"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"}