var w = Object.defineProperty;
var S = (p, t, e) => t in p ? w(p, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : p[t] = e;
var o = (p, t, e) => S(p, typeof t != "symbol" ? t + "" : t, e);
const m = class m {
  static validate(t) {
    if (this.validateSpeed(t.speed), this.validateDirection(t.direction), this.validateGap(t.gap), t.contentValidation ? t.contentValidation = {
      maxLength: t.contentValidation.maxLength || this.DEFAULT_MAX_LENGTH,
      forbiddenTags: [...this.FORBIDDEN_TAGS, ...t.contentValidation.forbiddenTags || []],
      forbiddenAttributes: [
        ...this.FORBIDDEN_ATTRIBUTES,
        ...t.contentValidation.forbiddenAttributes || []
      ]
    } : t.contentValidation = this.DEFAULT_VALIDATION_OPTIONS, t.contentList) {
      const e = this.validateContentList(t.contentList, t);
      e.isValid || (console.warn(
        "MarqueeJS: Content list validation failed:",
        e.errors.map((n) => n.message).join(", ")
      ), t.contentList = t.contentList.filter(
        (n, i) => !e.errors.some((s) => s.index === i)
      ));
    }
    return t.cloneCount !== void 0 && (t.cloneCount === "auto" || (!Number.isInteger(t.cloneCount) || t.cloneCount < 0 ? (console.warn(
      `MarqueeJS: Requested ${t.cloneCount} clones, but minimum is ${this.MIN_CLONES}. Using ${this.MIN_CLONES} clones instead.`
    ), t.cloneCount = this.MIN_CLONES) : typeof t.cloneCount == "number" && t.cloneCount > this.MAX_CLONES && (console.warn(
      `MarqueeJS: Requested ${t.cloneCount} clones, but maximum is ${this.MAX_CLONES}. Using ${this.MAX_CLONES} clones instead.`
    ), t.cloneCount = this.MAX_CLONES))), ["up", "down"].includes(t.direction || "") && t.separator && (console.warn(
      "MarqueeJS: Separator is not supported for vertical directions. Separator will be ignored."
    ), t.separator = ""), this.validateContainerHeight(t.containerHeight, t.direction), this.validateKeepOriginalContent(t.keepOriginalContent), this.validateContentValidationOptions(t.contentValidation), t;
  }
  static validateContentList(t, e) {
    var r, c, l;
    const n = [];
    if (!Array.isArray(t))
      return {
        isValid: !1,
        errors: [
          {
            type: "INVALID_HTML",
            message: "Content list must be an array of strings"
          }
        ]
      };
    const i = {
      ...this.DEFAULT_VALIDATION_OPTIONS,
      ...e.contentValidation,
      forbiddenTags: [...this.FORBIDDEN_TAGS, ...((r = e.contentValidation) == null ? void 0 : r.forbiddenTags) || []],
      forbiddenAttributes: [
        ...this.FORBIDDEN_ATTRIBUTES,
        ...((c = e.contentValidation) == null ? void 0 : c.forbiddenAttributes) || []
      ],
      maxLength: ((l = e.contentValidation) == null ? void 0 : l.maxLength) || this.DEFAULT_MAX_LENGTH
    }, s = new RegExp(
      `</?(?:${i.forbiddenTags.join("|")})\\b[^>]*>`,
      "i"
    ), a = new RegExp(
      i.forbiddenAttributes.map((h) => `${h}\\s*=\\s*["']?[^"']*["']?`).join("|"),
      "i"
    );
    for (let h = 0; h < t.length; h++) {
      const u = t[h];
      if (!u || typeof u != "string") {
        n.push({
          type: "EMPTY_CONTENT",
          message: "Content item must be a non-empty string",
          index: h,
          content: u
        });
        continue;
      }
      if (s.test(u)) {
        n.push({
          type: "UNSAFE_TAG_DETECTED",
          message: "Content contains forbidden HTML tags",
          index: h,
          content: u.substring(0, 50) + "..."
        });
        continue;
      }
      if (a.test(u)) {
        n.push({
          type: "UNSAFE_ATTRIBUTES",
          message: "Content contains forbidden HTML attributes",
          index: h,
          content: u.substring(0, 50) + "..."
        });
        continue;
      }
      u.length > i.maxLength && n.push({
        type: "MAX_LENGTH_EXCEEDED",
        message: `Content item exceeds maximum length of ${i.maxLength} characters`,
        index: h,
        content: u.substring(0, 50) + "..."
      });
    }
    return {
      isValid: n.length === 0,
      errors: n
    };
  }
  static validateContentValidationOptions(t) {
    if (t.maxLength !== void 0 && (typeof t.maxLength != "number" || t.maxLength <= 0))
      throw new Error("MarqueeJS: maxLength must be a positive number");
    if (t.forbiddenTags !== void 0 && (!Array.isArray(t.forbiddenTags) || t.forbiddenTags.some((e) => typeof e != "string")))
      throw new Error("MarqueeJS: forbiddenTags must be an array of strings");
    if (t.forbiddenAttributes !== void 0 && (!Array.isArray(t.forbiddenAttributes) || t.forbiddenAttributes.some((e) => typeof e != "string")))
      throw new Error("MarqueeJS: forbiddenAttributes must be an array of strings");
  }
  static validateSpeed(t) {
    if (t !== void 0 && (typeof t != "number" || t <= 0))
      throw new Error("MarqueeJS: Speed must be a positive number");
  }
  static validateDirection(t) {
    const e = ["left", "right", "up", "down"];
    if (t && !e.includes(t))
      throw new Error(`MarqueeJS: Direction must be one of: ${e.join(", ")}`);
  }
  static validateGap(t) {
    if (t !== void 0 && (typeof t != "number" || t < 0))
      throw new Error("MarqueeJS: Gap must be a non-negative number");
  }
  static validateContainerHeight(t, e) {
    if (t !== void 0) {
      if (typeof t != "number" || t <= 0)
        throw new Error("MarqueeJS: Container height must be a positive number");
      ["up", "down"].includes(e || "") || console.warn(
        'MarqueeJS: Container height is only applicable for "up" and "down" directions. Ignoring containerHeight.'
      );
    }
  }
  static validateKeepOriginalContent(t) {
    if (t !== void 0 && typeof t != "boolean")
      throw new Error("MarqueeJS: keepOriginalContent must be a boolean");
  }
  static validateCloneCount(t) {
    if (t !== "auto" && (!Number.isInteger(t) || t < 0 || t > this.MAX_CLONES))
      throw new Error(
        `MarqueeJS: cloneCount must be 'auto' or an integer between ${this.MIN_CLONES} and ${this.MAX_CLONES}`
      );
  }
};
o(m, "MAX_CLONES", 30), o(m, "MIN_CLONES", 0), o(m, "DEFAULT_MAX_LENGTH", 8500), o(m, "FORBIDDEN_TAGS", [
  "script",
  "style",
  "iframe",
  "object",
  "embed",
  "form",
  "svg",
  "input",
  "button",
  "meta",
  "link",
  "head",
  "html",
  "body"
]), o(m, "FORBIDDEN_ATTRIBUTES", [
  "onclick",
  "onmouseover",
  "onmouseout",
  "onload",
  "onerror",
  "onsubmit",
  "formaction",
  "xlink:href",
  "action",
  "javascript"
]), o(m, "DEFAULT_VALIDATION_OPTIONS", {
  maxLength: m.DEFAULT_MAX_LENGTH,
  forbiddenTags: m.FORBIDDEN_TAGS,
  forbiddenAttributes: m.FORBIDDEN_ATTRIBUTES
});
let d = m;
class f {
  /**
   * Sets up initial positions for an array of HTML elements, either horizontally or vertically.
   * Each element is positioned sequentially with a specified gap between them.
   *
   * @param elements - Array of HTMLElements to be positioned
   * @param isHorizontal - If true, elements are positioned horizontally; if false, vertically
   * @param gap - The spacing between elements in pixels
   * @returns Array of {@link PositionedElement} containing each element and its position
   *
   * @example
   * ```typescript
   * const elements = document.querySelectorAll('.item');
   * const positionedElements = PositionManager.setupElementsInitialPosition(
   *   Array.from(elements),
   *   true,
   *   10
   * );
   * ```
   */
  static setupElementsInitialPosition(t, e, n) {
    let i = 0;
    return t.map((a) => {
      const r = a.getBoundingClientRect(), c = e ? r.width + n : r.height + n, l = i;
      return f.positionElement(a, l, e), i += c, { el: a, position: l };
    });
  }
  /**
   * Positions an HTML element using absolute positioning and CSS transforms.
   * @param element - The HTML element to position
   * @param position - The position value in pixels
   * @param isHorizontal - If true, positions horizontally (X axis). If false/undefined, positions vertically (Y axis)
   * @returns void
   */
  static positionElement(t, e, n) {
    t && (t.style.position = "absolute", t.style.willChange = "transform", t.style.transform = n ? `translate3d(${e}px, 0, 0)` : `translate3d(0, ${e}px, 0)`);
  }
  /**
   * Positions a separator element relative to a target element with specified spacing and direction.
   *
   * @param target - The reference element to position the separator against
   * @param separator - The separator HTML element to be positioned
   * @param gap - The spacing between the target and separator in pixels
   * @param isLeftDirection - If true, positions separator from the left; if false, positions from the right
   *
   * @remarks
   * This method:
   * - Sets absolute positioning for the separator
   * - Aligns the separator vertically in the middle
   * - Applies performance optimizations using will-change
   * - Uses transform for vertical centering
   */
  static positionSeparator(t, e, n, i) {
    const s = t.getBoundingClientRect(), a = e.getBoundingClientRect(), r = s.width - a.width / 2 + n / 2;
    e.style.position = "absolute", i ? e.style.left = `${r}px` : e.style.right = `${r}px`, e.style.position = "absolute", e.style.top = "50%", e.style.lineHeight = "0.70", e.style.willChange = "transform", e.style.transform = "translate3d(0, -50%, 0)";
  }
  /**
   * Determines if an element is the furthest positioned element in a given array based on direction
   * @param item - Object containing the HTML element and its position
   * @param elements - Array of positioned elements to compare against
   * @param isHorizontal - Boolean indicating if the movement is horizontal
   * @param direction - Direction of movement ("left", "right", "up", or "down")
   * @returns Boolean indicating if the item is the furthest element in the specified direction
   */
  static isFurthestElement(t, e, n, i) {
    return !e.some((s) => s === t ? !1 : n ? i === "left" ? t.position >= s.position : t.position <= s.position : i === "up" ? t.position >= s.position : t.position <= s.position);
  }
  /**
   * Determines if a new position is available for an element without overlapping other elements.
   *
   * @param newPosition - The proposed position to check
   * @param currentElement - The HTML element being positioned
   * @param elements - Array of existing positioned elements with their positions
   * @param gap - Minimum space required between elements
   * @param isHorizontal - Direction of the marquee (true for horizontal, false for vertical)
   * @returns True if the position is available, false if it would overlap with existing elements
   *
   * @remarks
   * The function checks if placing an element at the new position would cause overlap with any existing
   * elements, taking into account the specified gap between elements. It ignores collision checks with
   * the current element itself.
   */
  static isPositionAvailable(t, e, n, i, s) {
    const a = i || 0;
    return !n.some(({ el: r, position: c }) => {
      if (r === e) return !1;
      const l = s ? e.offsetWidth : e.offsetHeight, h = s ? r.offsetWidth : r.offsetHeight;
      return t < c + h + a && t + l > c - a;
    });
  }
  /**
   * Updates the position of a given element within a marquee container.
   *
   * @param item - The element to be positioned with its current position data
   * @param elements - Array of all positioned elements in the marquee
   * @param wrapper - The HTML element wrapping all marquee elements
   * @param movement - The amount of pixels to move the element by
   * @param direction - The direction of movement ("left" | "right" | "up" | "down") type: <MarqueeDirectionValue>
   * @param gap - The spacing between elements
   *
   * @remarks
   * This method handles both horizontal and vertical movement.
   * It calculates new positions based on the direction and checks if the element needs to be repositioned
   * when it goes out of bounds. The actual position update only occurs if the new position is available
   * and the element is the furthest in its direction of travel.
   *
   * The position is applied using CSS transform translate3d for better performance.
   */
  static updatePosition(t, e, n, i, s, a) {
    var y, v;
    const r = ["left", "right"].includes(s), c = r ? ((y = n.parentElement) == null ? void 0 : y.offsetWidth) || 0 : ((v = n.parentElement) == null ? void 0 : v.offsetHeight) || 0, l = r ? t.el.offsetWidth + a : t.el.offsetHeight, h = ["left", "up"].includes(s);
    let u = !1, C = !1, g = 0;
    h ? (t.position -= i, t.position + l < 0 && (g = c)) : (t.position += i, (r ? t.position - a : t.position) > c && (g = -l)), u = f.isFurthestElement(t, e, r, s), C = f.isPositionAvailable(
      g,
      t.el,
      e,
      a,
      r
    ), C && u && g !== 0 && (t.position = g), r ? t.el.style.transform = `translate3d(${t.position}px, 0, 0)` : t.el.style.transform = `translate3d(0, ${t.position}px, 0)`;
  }
}
class L {
  constructor(t, e) {
    o(this, "wrapper");
    o(this, "options");
    o(this, "animationFrame", null);
    o(this, "lastTime", 0);
    o(this, "elements", []);
    o(this, "isHorizontal");
    o(this, "playing");
    this.wrapper = t, this.options = e, this.playing = !1, this.isHorizontal = ["left", "right"].includes(this.options.direction), this.setupElements();
  }
  /**
   * Sets up the initial positions of the wrapper's child elements.
   * This method processes all direct children of the wrapper element,
   * positions them using the PositionManager, and stores them for animation.
   *
   * The positioning is done according to:
   * - The horizontal/vertical orientation specified
   * - The gap between elements defined in options
   *
   * @private
   */
  setupElements() {
    const t = [...this.wrapper.children], e = f.setupElementsInitialPosition(
      t,
      this.isHorizontal,
      this.options.gap
    );
    this.elements = e;
  }
  /**
   * Initiates the animation loop for the marquee.
   * This method sets up a recursive animation frame request that:
   * 1. Calculates the time delta between frames
   * 2. Computes the movement distance based on speed and delta time
   * 3. Updates the position of each element in the marquee
   *
   * The animation continues until {@link stopAnimation} is called.
   *
   * @remarks
   * The animation uses requestAnimationFrame for smooth performance
   * and calculates movement based on elapsed time to ensure
   * consistent speed across different frame rates.
   */
  startAnimation() {
    this.lastTime = performance.now(), this.playing = !0;
    const t = (e) => {
      const n = e - this.lastTime;
      this.lastTime = e;
      const i = this.options.speed * n / 1e3;
      this.elements.forEach((s) => {
        f.updatePosition(
          s,
          this.elements,
          this.wrapper,
          i,
          this.options.direction,
          this.options.gap
        );
      }), this.animationFrame = requestAnimationFrame(t);
    };
    this.animationFrame = requestAnimationFrame(t);
  }
  /**
   * Stops the current animation by canceling the animation frame and resetting animation states.
   * This method will:
   * - Set the playing state to false
   * - Cancel any existing animation frame
   * - Reset the last recorded time
   */
  stopAnimation() {
    this.playing = !1, this.animationFrame && (cancelAnimationFrame(this.animationFrame), this.animationFrame = null), this.lastTime = 0;
  }
  /**
   * Recalculates positions of elements in the animation sequence.
   * This method performs a complete reset of the animation by:
   * 1. Stopping the current animation
   * 2. Reinitializing element positions
   * 3. Restarting the animation
   */
  recalculatePositions() {
    this.stopAnimation(), this.setupElements(), this.startAnimation();
  }
  /**
   * Checks whether animations are currently being played.
   * @returns {boolean} True if animations are playing, false otherwise.
   */
  isPlaying() {
    return this.playing;
  }
}
class M {
  constructor(t, e, n, i) {
    o(this, "wrapper");
    o(this, "options");
    o(this, "handlers");
    this.wrapper = e, this.options = n, this.handlers = i, this.init();
  }
  init() {
    this.setupHoverEvents(), this.setupTouchEvents(), this.setupVisibilityEvents();
  }
  setupHoverEvents() {
    this.options.pauseOnHover && (this.wrapper.addEventListener("mouseenter", this.handlers.pause), this.wrapper.addEventListener("mouseleave", this.handlers.resume));
  }
  setupTouchEvents() {
    let t, e;
    this.wrapper.addEventListener(
      "touchstart",
      (i) => {
        t = i.touches[0].clientX, e = i.touches[0].clientY, this.handlers.pause();
      },
      { passive: !0 }
    ), this.wrapper.addEventListener(
      "touchend",
      () => {
        this.handlers.resume();
      },
      { passive: !0 }
    );
    const n = (i) => {
      const s = i.touches[0].clientX - t, a = i.touches[0].clientY - e;
      (Math.abs(s) > Math.abs(a) && ["left", "right"].includes(this.options.direction) || Math.abs(a) > Math.abs(s) && ["up", "down"].includes(this.options.direction)) && i.preventDefault();
    };
    ["left", "right", "up", "down"].includes(this.options.direction) ? this.wrapper.addEventListener("touchmove", n, {
      passive: !1
    }) : this.wrapper.addEventListener("touchmove", n, {
      passive: !0
    });
  }
  setupVisibilityEvents() {
    document.addEventListener("visibilitychange", () => {
      document.hidden ? this.handlers.pause() : this.handlers.resume();
    });
  }
  destroy() {
    this.options.pauseOnHover && (this.wrapper.removeEventListener("mouseenter", this.handlers.pause), this.wrapper.removeEventListener("mouseleave", this.handlers.resume)), this.wrapper.removeEventListener("touchstart", this.handlers.pause), this.wrapper.removeEventListener("touchend", this.handlers.resume), document.removeEventListener("visibilitychange", this.handlers.pause);
  }
}
class b {
  constructor(t) {
    o(this, "cachedMetrics", null);
    this.direction = t;
  }
  /**
   * Calculates the optimal number of clones needed for smooth infinite scrolling.
   *
   * This method determines the minimum number of element clones required to ensure
   * continuous scrolling based on the container and content dimensions.
   * It includes caching optimization to avoid recalculation when metrics haven't changed.
   *
   * @param containerElement - The HTML element that serves as the scrolling container
   * @param contentElements - Array of HTML elements representing the content to be cloned
   * @param gap - The spacing between content elements in pixels
   * @returns The minimum number of clones needed for continuous scrolling
   *
   * @example
   * const cloneCount = calculator.calculateOptimalCloneCount(container, items, 10);
   */
  calculateOptimalCloneCount(t, e, n) {
    const i = ["left", "right"].includes(this.direction), s = this.calculateMetrics(t, e, n, i);
    if (this.cachedMetrics && this.cachedMetrics.containerSize === s.containerSize && this.cachedMetrics.contentSize === s.contentSize)
      return this.cachedMetrics.calculatedCount;
    const a = Math.ceil(s.containerSize / s.contentSize) + 1;
    return this.cachedMetrics = {
      ...s,
      calculatedCount: a
    }, a;
  }
  /**
   * Calculates the size metrics for a container and its elements
   * @param container - The HTML container element to measure
   * @param elements - Array of HTML elements inside the container to measure
   * @param gap - The gap size between elements
   * @param isHorizontal - Boolean flag indicating if the layout is horizontal (true) or vertical (false)
   * @returns An object containing the container size and total content size (including gaps)
   * @private
   */
  calculateMetrics(t, e, n, i) {
    const s = i ? t.offsetWidth : t.offsetHeight, a = e.reduce((r, c) => {
      const l = i ? c.offsetWidth : c.offsetHeight;
      return r + l + n;
    }, 0);
    return {
      containerSize: s,
      contentSize: a
    };
  }
  /**
   * Invalidates the cached metrics by setting them to null.
   * This forces a recalculation of metrics the next time they are requested.
   */
  invalidateCache() {
    this.cachedMetrics = null;
  }
}
class E {
  /**
   * Creates a container element for the marquee
   *
   * @returns {HTMLElement} - The container element
   */
  static createContainer(t, e) {
    var a;
    const n = document.createElement("div"), i = Array.from(t.classList), s = (a = t.id) != null && a.length ? t.id : void 0;
    return n.classList.add(e, "marquee-container"), n.classList.add(...i), s && (n.id = s), n.style.width = "100%", n.style.overflow = "hidden", n;
  }
  /**
   * Creates and configures an HTMLElement to serve as a wrapper for the marquee content.
   *
   * @returns {HTMLElement} A configured div element serving as the marquee wrapper
   */
  static createWrapper(t) {
    const e = document.createElement("div");
    return e.classList.add("marquee-wrapper"), e.style.position = "relative", e.style.width = "100%", e.style.height = "100%", e.style.overflow = "visible", e.style.display = t ? "flex" : "block", t && (e.style.alignItems = "center"), e;
  }
  /**
   * Creates a new HTMLElement to contain marquee content.
   *
   * @param content - The string content to be displayed inside the marquee element
   * @returns An HTMLElement configured with the appropriate styling and content
   */
  static createContentElement(t, e) {
    const n = document.createElement("div"), i = document.createElement("div");
    return n.className = "marquee-content-item", i.classList.add("marquee-content"), n.style.position = "absolute", n.style.whiteSpace = e ? "nowrap" : "normal", n.style.width = e ? "auto" : "100%", n.appendChild(i), i.innerHTML = t, n;
  }
  /**
   * Creates and configures a separator element for the marquee.
   * The separator element is a span that contains the configured separator content
   * and styles.
   *
   * @returns {HTMLElement} A new span element configured as a marquee separator
   */
  static createSeparatorElement(t, e) {
    const n = document.createElement("span");
    return n.className = "marquee-separator", n.innerHTML = `<span style="display: inline-block; ${e}">${t}</span>`, n.style.whiteSpace = "pre", n;
  }
}
class A {
  constructor(t, e) {
    o(this, "wrapper");
    o(this, "options");
    o(this, "isHorizontal");
    this.options = t, this.wrapper = e, this.isHorizontal = ["left", "right"].includes(t.direction);
  }
  /**
   * Updates the separator elements between marquee content items.
   * If no separator is defined in options or if the marquee is not horizontal direction, the method returns early.
   * This method first removes all existing separators and then creates new ones between each content item.
   * The separators are positioned based on the direction (left/right) and gap settings from the options.
   *
   * @remarks
   * This method is responsible for:
   * - Cleaning up existing separator elements
   * - Creating new separator elements between items
   * - Positioning separators according to direction and gap settings
   *
   * @throws {Error} Implicitly may throw if DOM operations fail
   */
  updateSeparators() {
    if (!this.options.separator || !this.isHorizontal) return;
    this.cleanupSeparatorElements();
    const t = this.wrapper.querySelectorAll(".marquee-content-item"), e = this.options.direction === "left";
    t.forEach((n) => {
      const i = E.createSeparatorElement(
        this.options.separator,
        this.options.separatorStyles
      );
      n.appendChild(i), f.positionSeparator(n, i, this.options.gap, e);
    });
  }
  /**
   * Removes all separator elements from the DOM that have the 'marquee-separator' class.
   * @returns {void}
   */
  cleanupSeparatorElements() {
    const t = this.wrapper.querySelectorAll(".marquee-separator");
    t == null || t.forEach((e) => e.remove());
  }
}
class T {
  constructor(t, e) {
    o(this, "container");
    o(this, "wrapper");
    o(this, "element");
    o(this, "options");
    o(this, "contentElements", []);
    o(this, "clones", []);
    o(this, "instanceId");
    o(this, "cloneCalculator");
    o(this, "isHorizontal");
    o(this, "separatorManager");
    this.isHorizontal = ["left", "right"].includes(e.direction), this.instanceId = `marquee-${Math.random().toString(36).substring(2, 9)}`, this.element = t, this.options = e, this.container = E.createContainer(this.element, this.instanceId), this.wrapper = E.createWrapper(this.isHorizontal), this.separatorManager = new A(this.options, this.wrapper), this.cloneCalculator = new b(e.direction), this.element.innerHTML = "", this.setupDOM();
  }
  setupDOM() {
    var e;
    const t = this.getMaxContentHeight();
    !this.isHorizontal && this.options.containerHeight ? this.container.style.height = `${this.options.containerHeight}px` : this.container.style.height = `${t}px`, (e = this.element.parentNode) == null || e.insertBefore(this.container, this.element), this.container.appendChild(this.wrapper), this.createContentElements();
  }
  async createContentElements() {
    this.clearElements();
    const t = document.createDocumentFragment();
    this.options.contentList.forEach((e) => {
      const n = E.createContentElement(e, this.isHorizontal);
      this.contentElements.push(n), t.appendChild(n);
    }), this.wrapper.appendChild(t), this.positionElements(), await this.createClones(), this.updateSeparators();
  }
  clearElements() {
    this.contentElements.forEach((t) => t.remove()), this.clones.forEach((t) => t.remove()), this.contentElements = [], this.clones = [];
  }
  getMaxContentHeight() {
    const t = document.createElement("div"), e = this.options.heightSecurityMargin || 0;
    t.style.position = "absolute", t.style.visibility = "hidden", t.style.left = "-9999px", document.body.appendChild(t);
    const n = this.options.contentList.map((i) => (t.innerHTML = i, t.offsetHeight + e));
    return document.body.removeChild(t), Math.max(...n, 0);
  }
  calculateMetrics() {
    const t = this.isHorizontal, e = [];
    let n = 0;
    return this.contentElements.forEach((i) => {
      const s = i.getBoundingClientRect(), a = t ? s.width : s.height;
      e.push({
        size: a,
        spacing: this.options.gap,
        position: n
      }), n += a + this.options.gap;
    }), e;
  }
  positionElements() {
    const t = this.calculateMetrics();
    this.contentElements.forEach((e, n) => {
      const { position: i } = t[n];
      f.positionElement(e, i, this.isHorizontal);
    });
  }
  async createClones() {
    const t = this.options.cloneCount === "auto" ? this.cloneCalculator.calculateOptimalCloneCount(
      this.container,
      this.contentElements,
      this.options.gap
    ) : this.options.cloneCount;
    if (t <= 0) return;
    const e = this.calculateMetrics(), n = e.reduce((s, a) => s + a.size + a.spacing, 0), i = document.createDocumentFragment();
    for (let s = 0; s < t; s++) {
      const a = n * (s + 1);
      this.contentElements.forEach((r, c) => {
        const l = r.cloneNode(!0);
        l.setAttribute("aria-hidden", "true"), l.classList.add("marquee-cloned-item"), f.positionElement(l, e[c].position + a, this.isHorizontal), this.clones.push(l), i.appendChild(l);
      });
    }
    this.wrapper.appendChild(i);
  }
  // Utility method to force recalculation of clones
  recalculateClones() {
    this.cloneCalculator.invalidateCache(), this.createContentElements();
  }
  updateContainerHeight(t) {
    this.container && (this.container.style.height = `${t}px`);
  }
  getWrapper() {
    return this.wrapper;
  }
  getContainer() {
    return this.container;
  }
  getContentElements() {
    return this.contentElements;
  }
  updateSeparators() {
    this.separatorManager.updateSeparators();
  }
  destroy() {
    var t;
    this.clearElements(), this.wrapper.parentNode && (this.wrapper.parentNode.insertBefore(this.element, this.wrapper), this.container.remove()), (t = document.querySelector(`.${this.instanceId}`)) == null || t.remove();
  }
}
class H {
  constructor(t, e = {}) {
    o(this, "element");
    o(this, "originalElement");
    o(this, "options");
    o(this, "isPlaying", !1);
    o(this, "animationManager", null);
    o(this, "eventManager", null);
    o(this, "domManager", null);
    o(this, "htmlContentList", []);
    o(this, "defaultOptions", {
      speed: 100,
      direction: "left",
      pauseOnHover: !1,
      gap: 20,
      cloneCount: "auto",
      separator: "",
      separatorStyles: "",
      randomize: !1,
      contentList: [],
      startAfter: 0,
      heightSecurityMargin: 0
    });
    const n = typeof t == "string" ? document.querySelector(t) : t;
    if (!n)
      throw new Error("Invalid element selector");
    this.originalElement = n.cloneNode(!0), this.setupInstance(n, e), this.init();
  }
  setupInstance(t, e) {
    var i;
    const n = d.validate(e);
    this.element = t, this.options = { ...this.defaultOptions, ...n }, this.htmlContentList = Array.from(this.element.children).map((s) => s.outerHTML), (i = this.options.contentList) != null && i.length ? this.htmlContentList.length && this.options.keepOriginalContent && (this.options.contentList = [...this.htmlContentList, ...this.options.contentList]) : this.options.contentList = this.htmlContentList, this.options.randomize && (this.options.contentList = this.randomizeContent());
  }
  async init() {
    this.destroy(), this.domManager = new T(this.element, this.options), this.domManager.createContentElements();
    const t = this.domManager.getWrapper(), e = this.domManager.getContentElements();
    t && e.length > 0 && (this.animationManager = new L(t, this.options), this.eventManager = new M(this.element, t, this.options, {
      pause: () => this.pause(),
      resume: () => this.play()
    }), setTimeout(() => {
      this.play();
    }, this.options.startAfter));
  }
  randomizeContent() {
    const t = [...this.options.contentList];
    for (let e = t.length - 1; e > 0; e--) {
      const n = Math.floor(Math.random() * (e + 1));
      [t[e], t[n]] = [t[n], t[e]];
    }
    return t;
  }
  async reset() {
    return new Promise(async (t) => {
      this.pause();
      const e = this.originalElement.cloneNode(!0);
      this.element.parentElement && this.element.parentElement.replaceChild(e, this.element), await Promise.resolve(this.destroy()), this.setupInstance(e, this.options), await this.init(), t();
    });
  }
  destroy() {
    return new Promise((t) => {
      var e, n, i;
      this.pause(), (e = this.animationManager) == null || e.stopAnimation(), (n = this.eventManager) == null || n.destroy(), (i = this.domManager) == null || i.destroy(), requestAnimationFrame(() => {
        t();
      });
    });
  }
  play() {
    this.isPlaying || (this.isPlaying = !0, this.startAnimation());
  }
  pause() {
    this.isPlaying && (this.isPlaying = !1, this.stopAnimation());
  }
  startAnimation() {
    var t;
    (t = this.animationManager) == null || t.startAnimation();
  }
  stopAnimation() {
    var t;
    (t = this.animationManager) == null || t.stopAnimation();
  }
  async addContent(t, e = !1, n = !1, i) {
    var r, c;
    if (!t) return;
    n && this.pause();
    const s = Array.isArray(t) ? t : [t], a = d.validateContentList(s, this.options);
    if (!a.isValid) {
      console.warn(
        "MarqueeJS: Content validation failed:",
        a.errors.map((l) => l.message).join(", ")
      );
      return;
    }
    e ? this.options.contentList = [...s, ...this.options.contentList] : this.options.contentList = [...this.options.contentList, ...s], n ? await this.reset() : ((r = this.domManager) == null || r.createContentElements(), (c = this.animationManager) == null || c.recalculatePositions()), i && requestAnimationFrame(() => {
      i();
    });
  }
  replaceContent(t, e) {
    var i, s;
    if (!Array.isArray(t)) return;
    const n = d.validateContentList(t, this.options);
    if (!n.isValid) {
      console.warn(
        "MarqueeJS: Content validation failed:",
        n.errors.map((a) => a.message).join(", ")
      );
      return;
    }
    this.options.contentList = t, (i = this.domManager) == null || i.createContentElements(), (s = this.animationManager) == null || s.recalculatePositions(), e && requestAnimationFrame(() => {
      e();
    });
  }
  getContentList() {
    return this.options.contentList;
  }
  updateSpeed(t) {
    d.validateSpeed(t), this.options.speed = t;
  }
  updateGap(t) {
    var e, n;
    d.validateGap(t), this.options.gap = t, (e = this.domManager) == null || e.createContentElements(), (n = this.animationManager) == null || n.recalculatePositions();
  }
  updateSeparator(t) {
    var e, n;
    this.options.separator = t, (e = this.domManager) == null || e.createContentElements(), (n = this.animationManager) == null || n.recalculatePositions();
  }
  updateSeparatorStyles(t) {
    var e;
    this.options.separatorStyles = t, (e = this.domManager) == null || e.updateSeparators();
  }
  updateCloneCount(t) {
    var e, n;
    if (!Number.isInteger(t) || t < 0 || t > d.MAX_CLONES)
      throw new Error(
        `MarqueeJS: cloneCount must be an integer between 0 and ${d.MAX_CLONES}`
      );
    this.options.cloneCount = t, (e = this.domManager) == null || e.createContentElements(), (n = this.animationManager) == null || n.recalculatePositions();
  }
  updateContainerHeight(t) {
    var e, n;
    d.validateContainerHeight(t, this.options.direction), this.options.containerHeight = t, ["up", "down"].includes(this.options.direction) && ((e = this.domManager) == null || e.updateContainerHeight(t)), (n = this.animationManager) == null || n.recalculatePositions(), this.play();
  }
  updatePauseOnHover(t) {
    var e, n;
    this.options.pauseOnHover = t, (e = this.eventManager) == null || e.destroy(), this.eventManager = new M(
      this.element,
      (n = this.domManager) == null ? void 0 : n.getWrapper(),
      this.options,
      {
        pause: () => this.pause(),
        resume: () => this.play()
      }
    );
  }
  recalculatePositions() {
    var t;
    (t = this.animationManager) == null || t.recalculatePositions(), this.play();
  }
  randomize() {
    this.options.randomize = !0, this.reset();
  }
  switchDirection() {
    const t = {
      left: "right",
      right: "left",
      up: "down",
      down: "up"
    };
    this.options.direction = t[this.options.direction];
  }
  async patchContent(t, e, n = !1, i) {
    var r, c, l;
    if (!t) return;
    if (e !== "start" && e !== "end")
      throw new Error('MarqueeJS (patchContent): position must be either "start" or "end"');
    n && this.pause();
    const s = Array.isArray(t) ? t : [t], a = d.validateContentList(s, this.options);
    if (!a.isValid) {
      console.warn(
        "MarqueeJS: Content validation failed:",
        a.errors.map((h) => h.message).join(", ")
      );
      return;
    }
    if (!((r = this.options.contentList) != null && r.length))
      this.options.contentList = s;
    else if (s.length >= this.options.contentList.length)
      this.options.contentList = s;
    else {
      const h = [...this.options.contentList];
      if (e === "start")
        h.splice(0, s.length, ...s);
      else {
        const u = h.length - s.length;
        h.splice(u, s.length, ...s);
      }
      this.options.contentList = h;
    }
    n ? await this.reset() : ((c = this.domManager) == null || c.createContentElements(), (l = this.animationManager) == null || l.recalculatePositions()), i && requestAnimationFrame(() => {
      i();
    });
  }
}
function I(p, t = {}) {
  const e = new H(p, t);
  return {
    pause() {
      e.pause();
    },
    resume() {
      e.play();
    },
    destroy() {
      e.destroy();
    },
    addContent(n, i = !1, s = !1, a) {
      e.addContent(n, i, s, a);
    },
    replaceContent(n, i) {
      e.replaceContent(n, i);
    },
    getContentList() {
      return e.getContentList();
    },
    updateSpeed(n) {
      e.updateSpeed(n);
    },
    updateGap(n) {
      e.updateGap(n);
    },
    updateSeparator(n) {
      e.updateSeparator(n);
    },
    updateSeparatorStyles(n) {
      e.updateSeparatorStyles(n);
    },
    updateCloneCount(n) {
      e.updateCloneCount(n);
    },
    updateContainerHeight(n) {
      e.updateContainerHeight(n);
    },
    updatePauseOnHover(n) {
      e.updatePauseOnHover(n);
    },
    recalculatePositions() {
      e.recalculatePositions();
    },
    randomize() {
      e.randomize();
    },
    switchDirection() {
      e.switchDirection();
    },
    patchContent(n, i, s = !1, a) {
      e.patchContent(n, i, s, a);
    }
  };
}
export {
  I as marqueejs
};
//# sourceMappingURL=marqueejs.es.min.js.map
