{"version":3,"file":"marqueejs.es.min.js","sources":["../src/core/OptionsValidator.ts","../src/core/managers/PositionManager.ts","../src/core/managers/AnimationManager.ts","../src/core/managers/EventManager.ts","../src/core/managers/CloneCalculator.ts","../src/core/factories/ElementFactory.ts","../src/core/managers/SeparatorManager.ts","../src/core/managers/DOMManager.ts","../src/core/Marquee.ts","../src/index.ts"],"sourcesContent":["import type {\n  MarqueeOptions,\n  ContentValidationResult,\n  ContentValidationErrorType,\n  ContentValidationOptions,\n} from \"../types\";\n\nexport class OptionsValidator {\n  static readonly MAX_CLONES = 30;\n  static readonly MIN_CLONES = 0;\n  static readonly DEFAULT_MAX_LENGTH = 8500;\n\n  private static readonly FORBIDDEN_TAGS = [\n    \"script\",\n    \"style\",\n    \"iframe\",\n    \"object\",\n    \"embed\",\n    \"form\",\n    \"svg\",\n    \"input\",\n    \"button\",\n    \"meta\",\n    \"link\",\n    \"head\",\n    \"html\",\n    \"body\",\n  ];\n\n  private static readonly FORBIDDEN_ATTRIBUTES = [\n    \"onclick\",\n    \"onmouseover\",\n    \"onmouseout\",\n    \"onload\",\n    \"onerror\",\n    \"onsubmit\",\n    \"formaction\",\n    \"xlink:href\",\n    \"action\",\n    \"javascript\",\n  ];\n\n  private static readonly DEFAULT_VALIDATION_OPTIONS = {\n    maxLength: OptionsValidator.DEFAULT_MAX_LENGTH,\n    forbiddenTags: OptionsValidator.FORBIDDEN_TAGS,\n    forbiddenAttributes: OptionsValidator.FORBIDDEN_ATTRIBUTES,\n  } as const;\n\n  static validate(options: MarqueeOptions): MarqueeOptions {\n    this.validateSpeed(options.speed);\n    this.validateDirection(options.direction);\n    this.validateGap(options.gap);\n\n    // Initialize contentValidation with defaults if not provided\n    if (!options.contentValidation) {\n      options.contentValidation = this.DEFAULT_VALIDATION_OPTIONS;\n    } else {\n      options.contentValidation = {\n        maxLength: options.contentValidation.maxLength || this.DEFAULT_MAX_LENGTH,\n        forbiddenTags: [...this.FORBIDDEN_TAGS, ...(options.contentValidation.forbiddenTags || [])],\n        forbiddenAttributes: [\n          ...this.FORBIDDEN_ATTRIBUTES,\n          ...(options.contentValidation.forbiddenAttributes || []),\n        ],\n      };\n    }\n\n    // Add contentList validation\n    if (options.contentList) {\n      const validationResult = this.validateContentList(options.contentList, options);\n      if (!validationResult.isValid) {\n        console.warn(\n          \"MarqueeJS: Content list validation failed:\",\n          validationResult.errors.map((e) => e.message).join(\", \")\n        );\n        options.contentList = options.contentList.filter(\n          (_, index) => !validationResult.errors.some((e) => e.index === index)\n        );\n      }\n    }\n\n    // Handle clone count separately to return modified options\n    if (options.cloneCount !== undefined) {\n      if (options.cloneCount === \"auto\") {\n        // 'auto' est une valeur valide, ne rien faire\n      } else if (!Number.isInteger(options.cloneCount) || options.cloneCount < 0) {\n        console.warn(\n          `MarqueeJS: Requested ${options.cloneCount} clones, but minimum is ${this.MIN_CLONES}. Using ${this.MIN_CLONES} clones instead.`\n        );\n        options.cloneCount = this.MIN_CLONES;\n      } else if (typeof options.cloneCount === \"number\" && options.cloneCount > this.MAX_CLONES) {\n        console.warn(\n          `MarqueeJS: Requested ${options.cloneCount} clones, but maximum is ${this.MAX_CLONES}. Using ${this.MAX_CLONES} clones instead.`\n        );\n        options.cloneCount = this.MAX_CLONES;\n      }\n    }\n\n    // Remove separator for vertical directions\n    if ([\"up\", \"down\"].includes(options.direction || \"\") && options.separator) {\n      console.warn(\n        \"MarqueeJS: Separator is not supported for vertical directions. Separator will be ignored.\"\n      );\n      options.separator = \"\";\n    }\n\n    this.validateContainerHeight(options.containerHeight, options.direction);\n    this.validateKeepOriginalContent(options.keepOriginalContent);\n    this.validateContentValidationOptions(options.contentValidation);\n\n    return options;\n  }\n\n  public static validateContentList(\n    contentList: string[],\n    options: MarqueeOptions\n  ): ContentValidationResult {\n    const errors: {\n      type: ContentValidationErrorType;\n      message: string;\n      content?: string;\n      index?: number;\n    }[] = [];\n\n    if (!Array.isArray(contentList)) {\n      return {\n        isValid: false,\n        errors: [\n          {\n            type: \"INVALID_HTML\" as ContentValidationErrorType,\n            message: \"Content list must be an array of strings\",\n          },\n        ],\n      };\n    }\n\n    // Create a complete validation options object with all required properties\n    const validationOptions = {\n      ...this.DEFAULT_VALIDATION_OPTIONS,\n      ...options.contentValidation,\n      forbiddenTags: [...this.FORBIDDEN_TAGS, ...(options.contentValidation?.forbiddenTags || [])],\n      forbiddenAttributes: [\n        ...this.FORBIDDEN_ATTRIBUTES,\n        ...(options.contentValidation?.forbiddenAttributes || []),\n      ],\n      maxLength: options.contentValidation?.maxLength || this.DEFAULT_MAX_LENGTH,\n    };\n\n    const forbiddenTagsPattern = new RegExp(\n      `</?(?:${validationOptions.forbiddenTags.join(\"|\")})\\\\b[^>]*>`,\n      \"i\"\n    );\n    const forbiddenAttrsPattern = new RegExp(\n      validationOptions.forbiddenAttributes\n        .map((attr) => `${attr}\\\\s*=\\\\s*[\"']?[^\"']*[\"']?`)\n        .join(\"|\"),\n      \"i\"\n    );\n\n    for (let i = 0; i < contentList.length; i++) {\n      const content = contentList[i];\n\n      // Check for empty or non-string content\n      if (!content || typeof content !== \"string\") {\n        errors.push({\n          type: \"EMPTY_CONTENT\" as ContentValidationErrorType,\n          message: \"Content item must be a non-empty string\",\n          index: i,\n          content,\n        });\n        continue;\n      }\n\n      // Check for forbidden tags\n      if (forbiddenTagsPattern.test(content)) {\n        errors.push({\n          type: \"UNSAFE_TAG_DETECTED\" as ContentValidationErrorType,\n          message: \"Content contains forbidden HTML tags\",\n          index: i,\n          content: content.substring(0, 50) + \"...\",\n        });\n        continue;\n      }\n\n      // Check for forbidden attributes\n      if (forbiddenAttrsPattern.test(content)) {\n        errors.push({\n          type: \"UNSAFE_ATTRIBUTES\" as ContentValidationErrorType,\n          message: \"Content contains forbidden HTML attributes\",\n          index: i,\n          content: content.substring(0, 50) + \"...\",\n        });\n        continue;\n      }\n\n      // Check for user-defined or default length\n      if (content.length > validationOptions.maxLength) {\n        errors.push({\n          type: \"MAX_LENGTH_EXCEEDED\" as ContentValidationErrorType,\n          message: `Content item exceeds maximum length of ${validationOptions.maxLength} characters`,\n          index: i,\n          content: content.substring(0, 50) + \"...\",\n        });\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n\n  public static validateContentValidationOptions(\n    validationOptions: ContentValidationOptions\n  ): void {\n    if (\n      validationOptions.maxLength !== undefined &&\n      (typeof validationOptions.maxLength !== \"number\" || validationOptions.maxLength <= 0)\n    ) {\n      throw new Error(\"MarqueeJS: maxLength must be a positive number\");\n    }\n\n    if (\n      validationOptions.forbiddenTags !== undefined &&\n      (!Array.isArray(validationOptions.forbiddenTags) ||\n        validationOptions.forbiddenTags.some((tag) => typeof tag !== \"string\"))\n    ) {\n      throw new Error(\"MarqueeJS: forbiddenTags must be an array of strings\");\n    }\n\n    if (\n      validationOptions.forbiddenAttributes !== undefined &&\n      (!Array.isArray(validationOptions.forbiddenAttributes) ||\n        validationOptions.forbiddenAttributes.some((attr) => typeof attr !== \"string\"))\n    ) {\n      throw new Error(\"MarqueeJS: forbiddenAttributes must be an array of strings\");\n    }\n  }\n  public static validateSpeed(speed: number | undefined): void {\n    if (speed !== undefined && (typeof speed !== \"number\" || speed <= 0)) {\n      throw new Error(\"MarqueeJS: Speed must be a positive number\");\n    }\n  }\n\n  public static validateDirection(direction: string | undefined): void {\n    const validDirections = [\"left\", \"right\", \"up\", \"down\"];\n    if (direction && !validDirections.includes(direction)) {\n      throw new Error(`MarqueeJS: Direction must be one of: ${validDirections.join(\", \")}`);\n    }\n  }\n\n  public static validateGap(gap: number | undefined): void {\n    if (gap !== undefined && (typeof gap !== \"number\" || gap < 0)) {\n      throw new Error(\"MarqueeJS: Gap must be a non-negative number\");\n    }\n  }\n\n  public static validateContainerHeight(\n    containerHeight: number | undefined,\n    direction: string | undefined\n  ): void {\n    if (containerHeight !== undefined) {\n      if (typeof containerHeight !== \"number\" || containerHeight <= 0) {\n        throw new Error(\"MarqueeJS: Container height must be a positive number\");\n      }\n      if (![\"up\", \"down\"].includes(direction || \"\")) {\n        console.warn(\n          'MarqueeJS: Container height is only applicable for \"up\" and \"down\" directions. Ignoring containerHeight.'\n        );\n      }\n    }\n  }\n\n  public static validateKeepOriginalContent(keepOriginalContent: boolean | undefined): void {\n    if (keepOriginalContent !== undefined && typeof keepOriginalContent !== \"boolean\") {\n      throw new Error(\"MarqueeJS: keepOriginalContent must be a boolean\");\n    }\n  }\n\n  public static validateCloneCount(cloneCount: number | \"auto\"): void {\n    if (\n      cloneCount !== \"auto\" &&\n      (!Number.isInteger(cloneCount) || cloneCount < 0 || cloneCount > this.MAX_CLONES)\n    ) {\n      throw new Error(\n        `MarqueeJS: cloneCount must be 'auto' or an integer between ${this.MIN_CLONES} and ${this.MAX_CLONES}`\n      );\n    }\n  }\n}\n","import { MarqueeOptions, PositionedElement } from \"../../types\";\n\nexport class PositionManager {\n  /**\n   * Sets up initial positions for an array of HTML elements, either horizontally or vertically.\n   * Each element is positioned sequentially with a specified gap between them.\n   *\n   * @param elements - Array of HTMLElements to be positioned\n   * @param isHorizontal - If true, elements are positioned horizontally; if false, vertically\n   * @param gap - The spacing between elements in pixels\n   * @returns Array of {@link PositionedElement} containing each element and its position\n   *\n   * @example\n   * ```typescript\n   * const elements = document.querySelectorAll('.item');\n   * const positionedElements = PositionManager.setupElementsInitialPosition(\n   *   Array.from(elements),\n   *   true,\n   *   10\n   * );\n   * ```\n   */\n  public static setupElementsInitialPosition(\n    elements: HTMLElement[],\n    isHorizontal: boolean,\n    gap: number\n  ): Array<PositionedElement> {\n    let currentPosition = 0;\n    let maxSize = 0;\n\n    const positionedElements = elements.map((el): PositionedElement => {\n      const boudingRect = el.getBoundingClientRect();\n      const size = isHorizontal ? boudingRect.width + gap : boudingRect.height + gap;\n      const position = currentPosition;\n\n      PositionManager.positionElement(el, position, isHorizontal);\n\n      currentPosition += size;\n      maxSize = Math.max(maxSize, size);\n\n      return { el, position };\n    });\n\n    return positionedElements;\n  }\n  /**\n   * Positions an HTML element using absolute positioning and CSS transforms.\n   * @param element - The HTML element to position\n   * @param position - The position value in pixels\n   * @param isHorizontal - If true, positions horizontally (X axis). If false/undefined, positions vertically (Y axis)\n   * @returns void\n   */\n  public static positionElement(\n    element: HTMLElement,\n    position: number,\n    isHorizontal?: boolean\n  ): void {\n    if (!element) return;\n\n    element.style.position = \"absolute\";\n    element.style.willChange = \"transform\";\n    element.style.transform = isHorizontal\n      ? `translate3d(${position}px, 0, 0)`\n      : `translate3d(0, ${position}px, 0)`;\n  }\n\n  /**\n   * Positions a separator element relative to a target element with specified spacing and direction.\n   *\n   * @param target - The reference element to position the separator against\n   * @param separator - The separator HTML element to be positioned\n   * @param gap - The spacing between the target and separator in pixels\n   * @param isLeftDirection - If true, positions separator from the left; if false, positions from the right\n   *\n   * @remarks\n   * This method:\n   * - Sets absolute positioning for the separator\n   * - Aligns the separator vertically in the middle\n   * - Applies performance optimizations using will-change\n   * - Uses transform for vertical centering\n   */\n  public static positionSeparator(\n    target: Element,\n    separator: HTMLElement,\n    gap: number,\n    isLeftDirection: boolean\n  ): void {\n    const targetRect = target.getBoundingClientRect();\n    const separatorRect = separator.getBoundingClientRect();\n    const position = targetRect.width - separatorRect.width / 2 + gap / 2;\n\n    separator.style.position = \"absolute\";\n\n    if (isLeftDirection) {\n      separator.style.left = `${position}px`;\n    } else {\n      separator.style.right = `${position}px`;\n    }\n\n    separator.style.position = \"absolute\";\n    separator.style.top = \"50%\";\n    separator.style.lineHeight = \"0.70\";\n    separator.style.willChange = \"transform\";\n    separator.style.transform = \"translate3d(0, -50%, 0)\";\n  }\n\n  /**\n   * Determines if an element is the furthest positioned element in a given array based on direction\n   * @param item - Object containing the HTML element and its position\n   * @param elements - Array of positioned elements to compare against\n   * @param isHorizontal - Boolean indicating if the movement is horizontal\n   * @param direction - Direction of movement (\"left\", \"right\", \"up\", or \"down\")\n   * @returns Boolean indicating if the item is the furthest element in the specified direction\n   */\n  public static isFurthestElement(\n    item: {\n      el: HTMLElement;\n      position: number;\n    },\n    elements: Array<PositionedElement>,\n    isHorizontal: boolean,\n    direction: MarqueeOptions[\"direction\"]\n  ): boolean {\n    return !elements.some((other) => {\n      if (other === item) return false;\n      if (isHorizontal) {\n        return direction === \"left\"\n          ? item.position >= other.position\n          : item.position <= other.position;\n      } else {\n        return direction === \"up\"\n          ? item.position >= other.position\n          : item.position <= other.position;\n      }\n    });\n  }\n\n  /**\n   * Determines if a new position is available for an element without overlapping other elements.\n   *\n   * @param newPosition - The proposed position to check\n   * @param currentElement - The HTML element being positioned\n   * @param elements - Array of existing positioned elements with their positions\n   * @param gap - Minimum space required between elements\n   * @param isHorizontal - Direction of the marquee (true for horizontal, false for vertical)\n   * @returns True if the position is available, false if it would overlap with existing elements\n   *\n   * @remarks\n   * The function checks if placing an element at the new position would cause overlap with any existing\n   * elements, taking into account the specified gap between elements. It ignores collision checks with\n   * the current element itself.\n   */\n  public static isPositionAvailable(\n    newPosition: number,\n    currentElement: HTMLElement,\n    elements: Array<PositionedElement>,\n    gap: MarqueeOptions[\"gap\"],\n    isHorizontal: boolean\n  ): boolean {\n    const threshold = gap || 0;\n    return !elements.some(({ el, position }) => {\n      if (el === currentElement) return false;\n      const currentElSizeWatcher = isHorizontal\n        ? currentElement.offsetWidth\n        : currentElement.offsetHeight;\n      const elSizeWatcher = isHorizontal ? el.offsetWidth : el.offsetHeight;\n\n      return (\n        newPosition < position + elSizeWatcher + threshold &&\n        newPosition + currentElSizeWatcher > position - threshold\n      );\n    });\n  }\n\n  /**\n   * Updates the position of a given element within a marquee container.\n   *\n   * @param item - The element to be positioned with its current position data\n   * @param elements - Array of all positioned elements in the marquee\n   * @param wrapper - The HTML element wrapping all marquee elements\n   * @param movement - The amount of pixels to move the element by\n   * @param direction - The direction of movement (\"left\" | \"right\" | \"up\" | \"down\") type: <MarqueeDirectionValue>\n   * @param gap - The spacing between elements\n   *\n   * @remarks\n   * This method handles both horizontal and vertical movement.\n   * It calculates new positions based on the direction and checks if the element needs to be repositioned\n   * when it goes out of bounds. The actual position update only occurs if the new position is available\n   * and the element is the furthest in its direction of travel.\n   *\n   * The position is applied using CSS transform translate3d for better performance.\n   */\n  public static updatePosition(\n    item: PositionedElement,\n    elements: Array<PositionedElement>,\n    wrapper: HTMLElement,\n    movement: number,\n    direction: MarqueeOptions[\"direction\"],\n    gap: MarqueeOptions[\"gap\"]\n  ): void {\n    const isHorizontal = [\"left\", \"right\"].includes(direction!);\n    const wrapperRefSize = isHorizontal\n      ? wrapper.parentElement?.offsetWidth || 0\n      : wrapper.parentElement?.offsetHeight || 0;\n    const elementRefSize = isHorizontal ? item.el.offsetWidth + gap! : item.el.offsetHeight;\n    const isUpOrLeftDirection = [\"left\", \"up\"].includes(direction!);\n    let isFurthestElement = false;\n    let positionAvailable = false;\n    let newPosition = 0;\n\n    if (isUpOrLeftDirection) {\n      item.position -= movement;\n\n      if (item.position + elementRefSize < 0) {\n        newPosition = wrapperRefSize;\n      }\n    } else {\n      // here direction is right or down\n      item.position += movement;\n\n      const positionRef = isHorizontal ? item.position - gap! : item.position;\n\n      if (positionRef > wrapperRefSize) {\n        newPosition = -elementRefSize;\n      }\n    }\n\n    isFurthestElement = PositionManager.isFurthestElement(item, elements, isHorizontal, direction);\n    positionAvailable = PositionManager.isPositionAvailable(\n      newPosition,\n      item.el,\n      elements,\n      gap,\n      isHorizontal\n    );\n\n    if (positionAvailable && isFurthestElement && newPosition !== 0) {\n      item.position = newPosition;\n    }\n\n    if (isHorizontal) {\n      item.el.style.transform = `translate3d(${item.position}px, 0, 0)`;\n    } else {\n      item.el.style.transform = `translate3d(0, ${item.position}px, 0)`;\n    }\n  }\n}\n","import type { MarqueeOptions, PositionedElement } from \"../../types\";\nimport { PositionManager } from \"./PositionManager\";\n\nexport class AnimationManager {\n  private wrapper: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private animationFrame: number | null = null;\n  private lastTime: number = 0;\n  private elements: Array<PositionedElement> = [];\n  private isHorizontal: boolean;\n  public playing: boolean;\n\n  constructor(wrapper: HTMLElement, options: Partial<MarqueeOptions>) {\n    this.wrapper = wrapper;\n    this.options = options;\n    this.playing = false;\n    this.isHorizontal = [\"left\", \"right\"].includes(this.options.direction!);\n    this.setupElements();\n  }\n\n  /**\n   * Sets up the initial positions of the wrapper's child elements.\n   * This method processes all direct children of the wrapper element,\n   * positions them using the PositionManager, and stores them for animation.\n   *\n   * The positioning is done according to:\n   * - The horizontal/vertical orientation specified\n   * - The gap between elements defined in options\n   *\n   * @private\n   */\n  private setupElements(): void {\n    const groups = [...this.wrapper.children] as HTMLElement[];\n\n    const positionedElements = PositionManager.setupElementsInitialPosition(\n      groups,\n      this.isHorizontal,\n      this.options.gap!\n    );\n\n    this.elements = positionedElements;\n  }\n\n  /**\n   * Initiates the animation loop for the marquee.\n   * This method sets up a recursive animation frame request that:\n   * 1. Calculates the time delta between frames\n   * 2. Computes the movement distance based on speed and delta time\n   * 3. Updates the position of each element in the marquee\n   *\n   * The animation continues until {@link stopAnimation} is called.\n   *\n   * @remarks\n   * The animation uses requestAnimationFrame for smooth performance\n   * and calculates movement based on elapsed time to ensure\n   * consistent speed across different frame rates.\n   */\n  public startAnimation(): void {\n    this.lastTime = performance.now();\n    this.playing = true;\n\n    const animate = (currentTime: number) => {\n      const deltaTime = currentTime - this.lastTime;\n      this.lastTime = currentTime;\n      const movement = (this.options.speed! * deltaTime) / 1000;\n\n      // Update each element's position independently\n      this.elements.forEach((item) => {\n        PositionManager.updatePosition(\n          item,\n          this.elements,\n          this.wrapper,\n          movement,\n          this.options.direction!,\n          this.options.gap!\n        );\n      });\n\n      this.animationFrame = requestAnimationFrame(animate);\n    };\n\n    this.animationFrame = requestAnimationFrame(animate);\n  }\n\n  /**\n   * Stops the current animation by canceling the animation frame and resetting animation states.\n   * This method will:\n   * - Set the playing state to false\n   * - Cancel any existing animation frame\n   * - Reset the last recorded time\n   */\n  public stopAnimation(): void {\n    this.playing = false;\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n    this.lastTime = 0;\n  }\n\n  /**\n   * Recalculates positions of elements in the animation sequence.\n   * This method performs a complete reset of the animation by:\n   * 1. Stopping the current animation\n   * 2. Reinitializing element positions\n   * 3. Restarting the animation\n   */\n  public recalculatePositions(): void {\n    this.stopAnimation();\n    this.setupElements();\n    this.startAnimation();\n  }\n\n  /**\n   * Checks whether animations are currently being played.\n   * @returns {boolean} True if animations are playing, false otherwise.\n   */\n  public isPlaying(): boolean {\n    return this.playing;\n  }\n}\n","import type { MarqueeOptions } from \"../../types\";\n\nexport class EventManager {\n  private wrapper: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private handlers: {\n    pause: () => void;\n    resume: () => void;\n  };\n\n  constructor(\n    _element: HTMLElement,\n    wrapper: HTMLElement,\n    options: Partial<MarqueeOptions>,\n    handlers: { pause: () => void; resume: () => void }\n  ) {\n    this.wrapper = wrapper;\n    this.options = options;\n    this.handlers = handlers;\n    this.init();\n  }\n\n  private init(): void {\n    this.setupHoverEvents();\n    this.setupTouchEvents();\n    this.setupVisibilityEvents();\n  }\n\n  private setupHoverEvents(): void {\n    if (this.options.pauseOnHover) {\n      this.wrapper.addEventListener(\"mouseenter\", this.handlers.pause);\n      this.wrapper.addEventListener(\"mouseleave\", this.handlers.resume);\n    }\n  }\n\n  private setupTouchEvents(): void {\n    let touchStartX: number;\n    let touchStartY: number;\n\n    // Add passive touch start listener\n    this.wrapper.addEventListener(\n      \"touchstart\",\n      (e: TouchEvent) => {\n        touchStartX = e.touches[0].clientX;\n        touchStartY = e.touches[0].clientY;\n        this.handlers.pause();\n      },\n      { passive: true }\n    );\n\n    // Add passive touch end listener\n    this.wrapper.addEventListener(\n      \"touchend\",\n      () => {\n        this.handlers.resume();\n      },\n      { passive: true }\n    );\n\n    // Separate touch move handler that can prevent default\n    const handleTouchMove = (e: TouchEvent) => {\n      const deltaX = e.touches[0].clientX - touchStartX;\n      const deltaY = e.touches[0].clientY - touchStartY;\n\n      if (\n        Math.abs(deltaX) > Math.abs(deltaY) &&\n        [\"left\", \"right\"].includes(this.options.direction!)\n      ) {\n        e.preventDefault();\n      } else if (\n        Math.abs(deltaY) > Math.abs(deltaX) &&\n        [\"up\", \"down\"].includes(this.options.direction!)\n      ) {\n        e.preventDefault();\n      }\n    };\n\n    // Add non-passive touch move listener only when needed\n    if ([\"left\", \"right\", \"up\", \"down\"].includes(this.options.direction!)) {\n      this.wrapper.addEventListener(\"touchmove\", handleTouchMove, {\n        passive: false,\n      });\n    } else {\n      this.wrapper.addEventListener(\"touchmove\", handleTouchMove, {\n        passive: true,\n      });\n    }\n  }\n\n  private setupVisibilityEvents(): void {\n    document.addEventListener(\"visibilitychange\", () => {\n      if (document.hidden) {\n        this.handlers.pause();\n      } else {\n        this.handlers.resume();\n      }\n    });\n  }\n\n  public destroy(): void {\n    if (this.options.pauseOnHover) {\n      this.wrapper.removeEventListener(\"mouseenter\", this.handlers.pause);\n      this.wrapper.removeEventListener(\"mouseleave\", this.handlers.resume);\n    }\n\n    this.wrapper.removeEventListener(\"touchstart\", this.handlers.pause);\n    this.wrapper.removeEventListener(\"touchend\", this.handlers.resume);\n    document.removeEventListener(\"visibilitychange\", this.handlers.pause);\n  }\n}\n","import type { CloneMetrics, MarqueeOptions } from \"../../types\";\n\nexport class CloneCalculator {\n  private cachedMetrics: CloneMetrics | null = null;\n\n  constructor(private direction: Partial<MarqueeOptions[\"direction\"]>) {}\n\n  /**\n   * Calculates the optimal number of clones needed for smooth infinite scrolling.\n   *\n   * This method determines the minimum number of element clones required to ensure\n   * continuous scrolling based on the container and content dimensions.\n   * It includes caching optimization to avoid recalculation when metrics haven't changed.\n   *\n   * @param containerElement - The HTML element that serves as the scrolling container\n   * @param contentElements - Array of HTML elements representing the content to be cloned\n   * @param gap - The spacing between content elements in pixels\n   * @returns The minimum number of clones needed for continuous scrolling\n   *\n   * @example\n   * const cloneCount = calculator.calculateOptimalCloneCount(container, items, 10);\n   */\n  public calculateOptimalCloneCount(\n    containerElement: HTMLElement,\n    contentElements: HTMLElement[],\n    gap: number\n  ): number {\n    const isHorizontal = [\"left\", \"right\"].includes(this.direction!);\n\n    const metrics = this.calculateMetrics(containerElement, contentElements, gap, isHorizontal);\n\n    // If metrics are identical, return from cache\n    if (\n      this.cachedMetrics &&\n      this.cachedMetrics.containerSize === metrics.containerSize &&\n      this.cachedMetrics.contentSize === metrics.contentSize\n    ) {\n      return this.cachedMetrics.calculatedCount;\n    }\n\n    // Calculate minimum number of clones needed\n    // (+1 to ensure continuous scrolling)\n    const minClones = Math.ceil(metrics.containerSize / metrics.contentSize) + 1;\n\n    // Cache the new metrics\n    this.cachedMetrics = {\n      ...metrics,\n      calculatedCount: minClones,\n    };\n\n    return minClones;\n  }\n\n  /**\n   * Calculates the size metrics for a container and its elements\n   * @param container - The HTML container element to measure\n   * @param elements - Array of HTML elements inside the container to measure\n   * @param gap - The gap size between elements\n   * @param isHorizontal - Boolean flag indicating if the layout is horizontal (true) or vertical (false)\n   * @returns An object containing the container size and total content size (including gaps)\n   * @private\n   */\n  private calculateMetrics(\n    container: HTMLElement,\n    elements: HTMLElement[],\n    gap: number,\n    isHorizontal: boolean\n  ): Omit<CloneMetrics, \"calculatedCount\"> {\n    const containerSize = isHorizontal ? container.offsetWidth : container.offsetHeight;\n\n    const contentSize = elements.reduce((total, el) => {\n      const size = isHorizontal ? el.offsetWidth : el.offsetHeight;\n      return total + size + gap;\n    }, 0);\n\n    return {\n      containerSize,\n      contentSize,\n    };\n  }\n\n  /**\n   * Invalidates the cached metrics by setting them to null.\n   * This forces a recalculation of metrics the next time they are requested.\n   */\n  public invalidateCache(): void {\n    this.cachedMetrics = null;\n  }\n}\n","/**\n * Factory class responsible for creating and configuring DOM elements for the marquee component.\n *\n * @class ElementFactory\n *\n * @property {string} instanceId - Unique identifier for the marquee instance\n * @property {Partial<MarqueeOptions>} options - Configuration options for the marquee\n * @property {HTMLElement} element - The base HTML element to transform into a marquee\n * @property {boolean} isHorizontal - Indicates if the marquee scrolls horizontally\n */\nexport class ElementFactory {\n  /**\n   * Creates a container element for the marquee\n   *\n   * @returns {HTMLElement} - The container element\n   */\n  public static createContainer(element: HTMLElement, instanceId: string): HTMLElement {\n    const container = document.createElement(\"div\");\n    const elementClasses = Array.from(element.classList);\n    const elementId = element.id?.length ? element.id : undefined;\n\n    container.classList.add(instanceId, \"marquee-container\");\n    container.classList.add(...elementClasses);\n\n    if (elementId) {\n      container.id = elementId;\n    }\n\n    container.style.width = \"100%\";\n    container.style.overflow = \"hidden\";\n\n    return container;\n  }\n\n  /**\n   * Creates and configures an HTMLElement to serve as a wrapper for the marquee content.\n   *\n   * @returns {HTMLElement} A configured div element serving as the marquee wrapper\n   */\n  public static createWrapper(isHorizontal: boolean): HTMLElement {\n    const wrapper = document.createElement(\"div\");\n    wrapper.classList.add(\"marquee-wrapper\");\n    wrapper.style.position = \"relative\";\n    wrapper.style.width = \"100%\";\n    wrapper.style.height = \"100%\";\n    wrapper.style.overflow = \"visible\";\n    wrapper.style.display = isHorizontal ? \"flex\" : \"block\";\n\n    if (isHorizontal) {\n      wrapper.style.alignItems = \"center\";\n    }\n\n    return wrapper;\n  }\n\n  /**\n   * Creates a new HTMLElement to contain marquee content.\n   *\n   * @param content - The string content to be displayed inside the marquee element\n   * @returns An HTMLElement configured with the appropriate styling and content\n   */\n  public static createContentElement(content: string, isHorizontal: boolean): HTMLElement {\n    const element = document.createElement(\"div\");\n    const contentEl = document.createElement(\"div\");\n    element.className = \"marquee-content-item\";\n    contentEl.classList.add(\"marquee-content\");\n    element.style.position = \"absolute\";\n    element.style.whiteSpace = !isHorizontal ? \"normal\" : \"nowrap\";\n    element.style.width = !isHorizontal ? \"100%\" : \"auto\";\n    element.appendChild(contentEl);\n    contentEl.innerHTML = content;\n    return element;\n  }\n\n  /**\n   * Creates and configures a separator element for the marquee.\n   * The separator element is a span that contains the configured separator content\n   * and styles.\n   *\n   * @returns {HTMLElement} A new span element configured as a marquee separator\n   */\n  public static createSeparatorElement(theSeparator: string, separatorStyles: string): HTMLElement {\n    const separator = document.createElement(\"span\");\n    separator.className = \"marquee-separator\";\n    separator.innerHTML = `<span style=\"display: inline-block; ${separatorStyles}\">${theSeparator}</span>`;\n    separator.style.whiteSpace = \"pre\";\n    return separator;\n  }\n}\n","import { MarqueeOptions } from \"../../types\";\nimport { ElementFactory } from \"../factories/ElementFactory\";\nimport { PositionManager } from \"./PositionManager\";\n\nexport class SeparatorManager {\n  private wrapper: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private isHorizontal: boolean;\n\n  constructor(options: Partial<MarqueeOptions>, wrapper: HTMLElement) {\n    this.options = options;\n    this.wrapper = wrapper;\n    this.isHorizontal = [\"left\", \"right\"].includes(options.direction!);\n  }\n\n  /**\n   * Updates the separator elements between marquee content items.\n   * If no separator is defined in options or if the marquee is not horizontal direction, the method returns early.\n   * This method first removes all existing separators and then creates new ones between each content item.\n   * The separators are positioned based on the direction (left/right) and gap settings from the options.\n   *\n   * @remarks\n   * This method is responsible for:\n   * - Cleaning up existing separator elements\n   * - Creating new separator elements between items\n   * - Positioning separators according to direction and gap settings\n   *\n   * @throws {Error} Implicitly may throw if DOM operations fail\n   */\n  public updateSeparators(): void {\n    if (!this.options.separator || !this.isHorizontal) return;\n\n    this.cleanupSeparatorElements();\n    const elements = this.wrapper.querySelectorAll(\".marquee-content-item\");\n    const isLeftDirection = this.options.direction === \"left\";\n\n    // Create new separators between items\n    elements.forEach((el) => {\n      const separator = ElementFactory.createSeparatorElement(\n        this.options.separator!,\n        this.options.separatorStyles!\n      );\n      el.appendChild(separator);\n      PositionManager.positionSeparator(el, separator, this.options.gap!, isLeftDirection);\n    });\n  }\n\n  /**\n   * Removes all separator elements from the DOM that have the 'marquee-separator' class.\n   * @returns {void}\n   */\n  public cleanupSeparatorElements(): void {\n    const separators = this.wrapper.querySelectorAll(\".marquee-separator\");\n    separators?.forEach((separator) => separator.remove());\n  }\n}\n","import type { MarqueeOptions, ElementMetrics } from \"../../types\";\nimport { CloneCalculator } from \"./CloneCalculator\";\nimport { ElementFactory } from \"../factories/ElementFactory\";\nimport { SeparatorManager } from \"./SeparatorManager\";\nimport { PositionManager } from \"./PositionManager\";\n\nexport class DOMManager {\n  private container: HTMLElement;\n  private wrapper: HTMLElement;\n  private element: HTMLElement;\n  private options: Partial<MarqueeOptions>;\n  private contentElements: HTMLElement[] = [];\n  private clones: HTMLElement[] = [];\n  private instanceId: string;\n  private cloneCalculator: CloneCalculator;\n  private isHorizontal: boolean;\n  private separatorManager: SeparatorManager;\n\n  constructor(element: HTMLElement, options: Partial<MarqueeOptions>) {\n    this.isHorizontal = [\"left\", \"right\"].includes(options.direction!);\n    this.instanceId = `marquee-${Math.random().toString(36).substring(2, 9)}`;\n    this.element = element;\n    this.options = options;\n    this.container = ElementFactory.createContainer(this.element, this.instanceId);\n    this.wrapper = ElementFactory.createWrapper(this.isHorizontal);\n    this.separatorManager = new SeparatorManager(this.options, this.wrapper);\n    this.cloneCalculator = new CloneCalculator(options.direction!);\n    // Clear original element since everything goes through contentList\n    this.element.innerHTML = \"\";\n\n    this.setupDOM();\n  }\n\n  public setupDOM(): void {\n    const originalHeight = this.getMaxContentHeight();\n\n    // Configure container height\n    if (!this.isHorizontal && this.options.containerHeight) {\n      this.container.style.height = `${this.options.containerHeight}px`;\n    } else {\n      this.container.style.height = `${originalHeight}px`;\n    }\n\n    // Insert into DOM\n    this.element.parentNode?.insertBefore(this.container, this.element);\n    this.container.appendChild(this.wrapper);\n\n    // Create content elements from contentList\n    this.createContentElements();\n  }\n\n  public async createContentElements(): Promise<void> {\n    // Clear existing elements\n    this.clearElements();\n\n    const fragment = document.createDocumentFragment();\n    this.options.contentList!.forEach((content) => {\n      const element = ElementFactory.createContentElement(content, this.isHorizontal);\n      this.contentElements.push(element);\n      fragment.appendChild(element);\n    });\n\n    this.wrapper.appendChild(fragment);\n    this.positionElements();\n    await this.createClones();\n\n    // Add separator styles after creating elements\n    this.updateSeparators();\n  }\n\n  private clearElements(): void {\n    this.contentElements.forEach((el) => el.remove());\n    this.clones.forEach((el) => el.remove());\n    this.contentElements = [];\n    this.clones = [];\n  }\n\n  private getMaxContentHeight(): number {\n    const temp = document.createElement(\"div\");\n    const heightSecurityMargin = this.options.heightSecurityMargin || 0;\n    temp.style.position = \"absolute\";\n    temp.style.visibility = \"hidden\";\n    temp.style.left = \"-9999px\";\n    document.body.appendChild(temp);\n\n    const heights = this.options.contentList!.map((content) => {\n      temp.innerHTML = content;\n      return temp.offsetHeight + heightSecurityMargin;\n    });\n\n    document.body.removeChild(temp);\n    return Math.max(...heights, 0);\n  }\n\n  private calculateMetrics(): ElementMetrics[] {\n    const isHorizontal = this.isHorizontal;\n    const metrics: ElementMetrics[] = [];\n    let currentPosition = 0;\n\n    this.contentElements.forEach((el) => {\n      const rect = el.getBoundingClientRect();\n      const size = isHorizontal ? rect.width : rect.height;\n\n      metrics.push({\n        size,\n        spacing: this.options.gap!,\n        position: currentPosition,\n      });\n\n      currentPosition += size + this.options.gap!;\n    });\n\n    return metrics;\n  }\n\n  private positionElements(): void {\n    const metrics = this.calculateMetrics();\n    this.contentElements.forEach((el, i) => {\n      const { position } = metrics[i];\n      PositionManager.positionElement(el, position, this.isHorizontal);\n    });\n  }\n\n  private async createClones(): Promise<void> {\n    // If cloneCount is 'auto', use CloneCalculator\n    const cloneCount =\n      this.options.cloneCount === \"auto\"\n        ? this.cloneCalculator.calculateOptimalCloneCount(\n            this.container,\n            this.contentElements,\n            this.options.gap!\n          )\n        : this.options.cloneCount!;\n\n    if (cloneCount! <= 0) return;\n\n    const metrics = this.calculateMetrics();\n    const totalSize = metrics.reduce((sum, m) => sum + m.size + m.spacing, 0);\n    const fragment = document.createDocumentFragment();\n\n    for (let i = 0; i < cloneCount; i++) {\n      const offset = totalSize * (i + 1);\n      this.contentElements.forEach((original, index) => {\n        const clone = original.cloneNode(true) as HTMLElement;\n        clone.setAttribute(\"aria-hidden\", \"true\");\n        clone.classList.add(\"marquee-cloned-item\");\n\n        PositionManager.positionElement(clone, metrics[index].position + offset, this.isHorizontal);\n\n        this.clones.push(clone);\n        fragment.appendChild(clone);\n      });\n    }\n\n    this.wrapper.appendChild(fragment);\n  }\n\n  // Utility method to force recalculation of clones\n  public recalculateClones(): void {\n    this.cloneCalculator.invalidateCache();\n    this.createContentElements();\n  }\n\n  public updateContainerHeight(height: number): void {\n    if (this.container) {\n      this.container.style.height = `${height}px`;\n    }\n  }\n\n  public getWrapper(): HTMLElement {\n    return this.wrapper;\n  }\n\n  public getContainer(): HTMLElement {\n    return this.container;\n  }\n\n  public getContentElements(): HTMLElement[] {\n    return this.contentElements;\n  }\n\n  public updateSeparators(): void {\n    this.separatorManager.updateSeparators();\n  }\n\n  public destroy(): void {\n    this.clearElements();\n    if (this.wrapper.parentNode) {\n      this.wrapper.parentNode.insertBefore(this.element, this.wrapper);\n      this.container.remove();\n    }\n\n    document.querySelector(`.${this.instanceId}`)?.remove();\n  }\n}\n","import type { MarqueeOptions } from \"../types\";\nimport { OptionsValidator } from \"./OptionsValidator\";\nimport { AnimationManager } from \"./managers/AnimationManager\";\nimport { EventManager } from \"./managers/EventManager\";\nimport { DOMManager } from \"./managers/DOMManager\";\n\nexport class Marquee {\n  private element!: HTMLElement;\n  private originalElement: HTMLElement;\n  private options!: Partial<MarqueeOptions>;\n  private isPlaying: boolean = false;\n  private animationManager: AnimationManager | null = null;\n  private eventManager: EventManager | null = null;\n  private domManager: DOMManager | null = null;\n  private htmlContentList: string[] = [];\n\n  private defaultOptions: Partial<MarqueeOptions> = {\n    speed: 100,\n    direction: \"left\",\n    pauseOnHover: false,\n    gap: 20,\n    cloneCount: \"auto\",\n    separator: \"\",\n    separatorStyles: \"\",\n    randomize: false,\n    contentList: [],\n    startAfter: 0,\n    heightSecurityMargin: 0,\n  };\n\n  constructor(selector: string | HTMLElement, options: MarqueeOptions = {}) {\n    const element = typeof selector === \"string\" ? document.querySelector(selector) : selector;\n\n    if (!element) {\n      throw new Error(\"Invalid element selector\");\n    }\n\n    // Store a deep copy of the original element\n    this.originalElement = element.cloneNode(true) as HTMLElement;\n    this.setupInstance(element as HTMLElement, options);\n    this.init();\n  }\n\n  private setupInstance(element: HTMLElement, options: MarqueeOptions): void {\n    const validatedOptions = OptionsValidator.validate(options);\n    this.element = element;\n    this.options = { ...this.defaultOptions, ...validatedOptions };\n    this.htmlContentList = Array.from(this.element.children).map((child) => child.outerHTML);\n\n    // If contentList is empty, populate it with the direct children of the marquee element\n    if (!this.options.contentList?.length) {\n      this.options.contentList = this.htmlContentList;\n    } else if (this.htmlContentList.length && this.options.keepOriginalContent) {\n      // If contentList is not empty, but the original content should be kept, append it to the contentList\n      this.options.contentList = [...this.htmlContentList, ...this.options.contentList];\n    }\n\n    // Randomize contentList if required\n    if (this.options.randomize) {\n      this.options.contentList = this.randomizeContent();\n    }\n  }\n\n  private async init(): Promise<void> {\n    // Cleanup existing managers if they exist\n    this.destroy();\n\n    this.domManager = new DOMManager(this.element, this.options);\n    this.domManager.createContentElements();\n\n    const wrapper = this.domManager.getWrapper();\n    const contentElements = this.domManager.getContentElements();\n\n    if (wrapper && contentElements.length > 0) {\n      this.animationManager = new AnimationManager(wrapper, this.options);\n      this.eventManager = new EventManager(this.element, wrapper, this.options, {\n        pause: () => this.pause(),\n        resume: () => this.play(),\n      });\n\n      setTimeout(() => {\n        this.play();\n      }, this.options.startAfter);\n    }\n  }\n\n  private randomizeContent(): string[] {\n    const shuffledContent = [...this.options.contentList!];\n    for (let i = shuffledContent.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffledContent[i], shuffledContent[j]] = [shuffledContent[j], shuffledContent[i]];\n    }\n    return shuffledContent;\n  }\n\n  public async reset(): Promise<void> {\n    return new Promise<void>(async (resolve) => {\n      // Stop current animation\n      this.pause();\n\n      // Recreate element from original\n      const newElement = this.originalElement.cloneNode(true) as HTMLElement;\n\n      // Replace old element with new one\n      if (this.element.parentElement) {\n        this.element.parentElement.replaceChild(newElement, this.element);\n      }\n\n      // Wait for cleanup to complete\n      await Promise.resolve(this.destroy());\n\n      // Completely reset the instance\n      this.setupInstance(newElement, this.options);\n\n      // Wait for initialization to complete\n      await this.init();\n\n      resolve();\n    });\n  }\n\n  public destroy(): Promise<void> {\n    return new Promise<void>((resolve) => {\n      this.pause();\n      this.animationManager?.stopAnimation();\n      this.eventManager?.destroy();\n      this.domManager?.destroy();\n\n      // S'assurer que le DOM a eu le temps de se mettre à jour\n      requestAnimationFrame(() => {\n        resolve();\n      });\n    });\n  }\n\n  public play(): void {\n    if (this.isPlaying) return;\n    this.isPlaying = true;\n    this.startAnimation();\n  }\n\n  public pause(): void {\n    if (!this.isPlaying) return;\n    this.isPlaying = false;\n    this.stopAnimation();\n  }\n\n  private startAnimation(): void {\n    this.animationManager?.startAnimation();\n  }\n\n  private stopAnimation(): void {\n    this.animationManager?.stopAnimation();\n  }\n\n  public async addContent(\n    content: string | string[],\n    addToStart: boolean = false,\n    reset: boolean = false,\n    callback?: () => void\n  ): Promise<void> {\n    if (!content) return;\n\n    if (reset) {\n      this.pause();\n    }\n\n    // Convert content to array if it's a string\n    const newContent = Array.isArray(content) ? content : [content];\n\n    // Validate new content\n    const validationResult = OptionsValidator.validateContentList(newContent, this.options);\n    if (!validationResult.isValid) {\n      console.warn(\n        \"MarqueeJS: Content validation failed:\",\n        validationResult.errors.map((e) => e.message).join(\", \")\n      );\n      return;\n    }\n\n    // Add new content to the contentList\n    if (addToStart) {\n      this.options.contentList = [...newContent, ...this.options.contentList!];\n    } else {\n      this.options.contentList = [...this.options.contentList!, ...newContent];\n    }\n\n    if (reset) {\n      // Wait for reset to complete\n      await this.reset();\n    } else {\n      // Recreate content elements\n      this.domManager?.createContentElements();\n\n      // Recalculate positions and restart animation\n      this.animationManager?.recalculatePositions();\n    }\n\n    if (callback) {\n      requestAnimationFrame(() => {\n        callback();\n      });\n    }\n  }\n\n  public replaceContent(newContentList: string[], callback?: () => void): void {\n    if (!Array.isArray(newContentList)) return;\n\n    // Validate new content list\n    const validationResult = OptionsValidator.validateContentList(newContentList, this.options);\n    if (!validationResult.isValid) {\n      console.warn(\n        \"MarqueeJS: Content validation failed:\",\n        validationResult.errors.map((e) => e.message).join(\", \")\n      );\n      return;\n    }\n\n    // Replace the contentList with the new one\n    this.options.contentList = newContentList;\n\n    // Recreate content elements\n    this.domManager?.createContentElements();\n\n    // Recalculate positions and restart animation\n    this.animationManager?.recalculatePositions();\n\n    if (callback) {\n      requestAnimationFrame(() => {\n        callback();\n      });\n    }\n  }\n\n  public getContentList(): string[] {\n    return this.options.contentList!;\n  }\n\n  public updateSpeed(speed: number): void {\n    OptionsValidator.validateSpeed(speed);\n    this.options.speed = speed;\n  }\n\n  public updateGap(gap: number): void {\n    OptionsValidator.validateGap(gap);\n    this.options.gap = gap;\n    this.domManager?.createContentElements();\n    this.animationManager?.recalculatePositions();\n  }\n\n  public updateSeparator(separator: string): void {\n    this.options.separator = separator;\n    this.domManager?.createContentElements();\n    this.animationManager?.recalculatePositions();\n  }\n\n  public updateSeparatorStyles(styles: string): void {\n    this.options.separatorStyles = styles;\n    this.domManager?.updateSeparators();\n  }\n\n  public updateCloneCount(cloneCount: number): void {\n    if (\n      !Number.isInteger(cloneCount) ||\n      cloneCount < 0 ||\n      cloneCount > OptionsValidator.MAX_CLONES\n    ) {\n      throw new Error(\n        `MarqueeJS: cloneCount must be an integer between 0 and ${OptionsValidator.MAX_CLONES}`\n      );\n    }\n    this.options.cloneCount = cloneCount;\n    this.domManager?.createContentElements();\n    this.animationManager?.recalculatePositions();\n  }\n\n  public updateContainerHeight(containerHeight: number): void {\n    OptionsValidator.validateContainerHeight(containerHeight, this.options.direction);\n    this.options.containerHeight = containerHeight;\n\n    // Apply forced height for 'up' and 'down' directions\n    if ([\"up\", \"down\"].includes(this.options.direction!)) {\n      this.domManager?.updateContainerHeight(containerHeight);\n    }\n\n    this.animationManager?.recalculatePositions();\n    this.play();\n  }\n\n  public updatePauseOnHover(pauseOnHover: boolean): void {\n    this.options.pauseOnHover = pauseOnHover;\n    this.eventManager?.destroy();\n    this.eventManager = new EventManager(\n      this.element,\n      this.domManager?.getWrapper()!,\n      this.options,\n      {\n        pause: () => this.pause(),\n        resume: () => this.play(),\n      }\n    );\n  }\n\n  public recalculatePositions(): void {\n    this.animationManager?.recalculatePositions();\n    this.play();\n  }\n\n  public randomize(): void {\n    this.options.randomize = true;\n    this.reset();\n  }\n\n  public switchDirection(): void {\n    const oppositeDirection: Record<string, MarqueeOptions[\"direction\"]> = {\n      left: \"right\",\n      right: \"left\",\n      up: \"down\",\n      down: \"up\",\n    };\n\n    this.options.direction = oppositeDirection[this.options.direction!];\n  }\n\n  public async patchContent(\n    content: string | string[],\n    position: \"start\" | \"end\",\n    reset: boolean = false,\n    callback?: () => void\n  ): Promise<void> {\n    if (!content) return;\n    if (position !== \"start\" && position !== \"end\") {\n      throw new Error('MarqueeJS (patchContent): position must be either \"start\" or \"end\"');\n    }\n\n    if (reset) {\n      this.pause();\n    }\n\n    // Convert content to array if it's a string\n    const newContent = Array.isArray(content) ? content : [content];\n\n    // Validate new content\n    const validationResult = OptionsValidator.validateContentList(newContent, this.options);\n    if (!validationResult.isValid) {\n      console.warn(\n        \"MarqueeJS: Content validation failed:\",\n        validationResult.errors.map((e) => e.message).join(\", \")\n      );\n      return;\n    }\n\n    // If current content list is empty, just use the new content\n    if (!this.options.contentList?.length) {\n      this.options.contentList = newContent;\n    } else {\n      // If new content length is greater or equal to current content\n      // replace everything\n      if (newContent.length >= this.options.contentList.length) {\n        this.options.contentList = newContent;\n      } else {\n        // Otherwise patch at specified position\n        const currentContent = [...this.options.contentList];\n        if (position === \"start\") {\n          // Replace elements at start\n          currentContent.splice(0, newContent.length, ...newContent);\n        } else {\n          // Replace elements at end\n          const startIndex = currentContent.length - newContent.length;\n          currentContent.splice(startIndex, newContent.length, ...newContent);\n        }\n        this.options.contentList = currentContent;\n      }\n    }\n\n    if (reset) {\n      // Wait for reset to complete\n      await this.reset();\n    } else {\n      // Recreate content elements\n      this.domManager?.createContentElements();\n\n      // Recalculate positions and restart animation\n      this.animationManager?.recalculatePositions();\n    }\n\n    if (callback) {\n      requestAnimationFrame(() => {\n        callback();\n      });\n    }\n  }\n}\n","import { Marquee } from \"./core/Marquee\";\nimport type { MarqueeOptions, MarqueeInstance } from \"./types\";\n\nexport function marqueejs(selector: string, options: MarqueeOptions = {}): MarqueeInstance {\n  const instance = new Marquee(selector, options);\n\n  return {\n    pause() {\n      instance.pause();\n    },\n    resume() {\n      instance.play();\n    },\n    destroy() {\n      instance.destroy();\n    },\n    addContent(\n      content: string | string[],\n      addToStart: boolean = false,\n      reset: boolean = false,\n      callback?: () => void\n    ) {\n      instance.addContent(content, addToStart, reset, callback);\n    },\n    replaceContent(newContentList: string[], callback?: () => void) {\n      instance.replaceContent(newContentList, callback);\n    },\n    getContentList() {\n      return instance.getContentList();\n    },\n    updateSpeed(speed: number) {\n      instance.updateSpeed(speed);\n    },\n    updateGap(gap: number) {\n      instance.updateGap(gap);\n    },\n    updateSeparator(separator: string) {\n      instance.updateSeparator(separator);\n    },\n    updateSeparatorStyles(styles: string) {\n      instance.updateSeparatorStyles(styles);\n    },\n    updateCloneCount(cloneCount: number) {\n      instance.updateCloneCount(cloneCount);\n    },\n    updateContainerHeight(containerHeight: number) {\n      instance.updateContainerHeight(containerHeight);\n    },\n    updatePauseOnHover(pauseOnHover: boolean) {\n      instance.updatePauseOnHover(pauseOnHover);\n    },\n    recalculatePositions() {\n      instance.recalculatePositions();\n    },\n    randomize() {\n      instance.randomize();\n    },\n    switchDirection() {\n      instance.switchDirection();\n    },\n    patchContent(\n      content: string | string[],\n      position: \"start\" | \"end\",\n      reset: boolean = false,\n      callback?: () => void\n    ) {\n      instance.patchContent(content, position, reset, callback);\n    },\n  };\n}\n\nexport type { MarqueeOptions, MarqueeInstance };\n"],"names":["_OptionsValidator","options","validationResult","e","_","index","contentList","_a","_b","_c","errors","validationOptions","forbiddenTagsPattern","forbiddenAttrsPattern","attr","i","content","tag","speed","direction","validDirections","gap","containerHeight","keepOriginalContent","cloneCount","__publicField","OptionsValidator","PositionManager","elements","isHorizontal","currentPosition","el","boudingRect","size","position","element","target","separator","isLeftDirection","targetRect","separatorRect","item","other","newPosition","currentElement","threshold","currentElSizeWatcher","elSizeWatcher","wrapper","movement","wrapperRefSize","elementRefSize","isUpOrLeftDirection","isFurthestElement","positionAvailable","AnimationManager","groups","positionedElements","animate","currentTime","deltaTime","EventManager","_element","handlers","touchStartX","touchStartY","handleTouchMove","deltaX","deltaY","CloneCalculator","containerElement","contentElements","metrics","minClones","container","containerSize","contentSize","total","ElementFactory","instanceId","elementClasses","elementId","contentEl","theSeparator","separatorStyles","SeparatorManager","separators","DOMManager","originalHeight","fragment","temp","heightSecurityMargin","heights","rect","totalSize","sum","m","offset","original","clone","height","Marquee","selector","validatedOptions","child","shuffledContent","j","resolve","newElement","addToStart","reset","callback","newContent","newContentList","styles","pauseOnHover","oppositeDirection","currentContent","startIndex","marqueejs","instance"],"mappings":"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"}